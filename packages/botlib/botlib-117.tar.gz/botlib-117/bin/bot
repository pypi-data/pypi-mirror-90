#!/usr/bin/python3
# BOTLIB - bot
#
# this file is placed in the public domain

"bot program"

# imports

import os, sys ; sys.path.insert(0, os.getcwd())

import atexit
import os
import pwd
import readline
import sys

from bot.hdl import Command, Handler, cmd
from bot.obj import format, get
from bot.prs import parse_cli
from bot.thr import launch
from bot.trm import execute

# defines

wd = os.path.expanduser("~/.bot")

# classes

class Console(Handler):

    "console class"

    def __init__(self):
        super().__init__()
        self.register("cmd", cmd)

    def announce(self, txt):
        "silence announcing"
        self.direct(txt)

    def direct(self, txt):
        "print to console"
        print(txt)

    def input(self):
        "loop for input"
        while 1:
            try:
                e = self.poll()
            except EOFError:
                break
            self.put(e)
            e.wait()

    def poll(self):
        "wait for input"
        return Command(input("> "))

    def say(self, channel, txt):
        "strip channel from output"
        self.direct(txt)

    def start(self):
        "start console"
        super().start()
        launch(self.input)

# functions

def complete(text, state):
    "complete matches"
    matches = []
    if text:
        matches = [s for s in cmds if s and s.startswith(text)]
    else:
        matches = cmds[:]
    try:
        return matches[state]
    except IndexError:
        return None

def setcompleter(commands):
    "set the completer"
    cmds.extend(commands)
    readline.set_completer(complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))

# runtime

cmds = []

def main():
    cfg = parse_cli(wd)
    c = Console()
    c.load("bot.cmd")
    if cfg.txt:
        return c.cmd(cfg.otxt)
    c.init(cfg.sets.mods)
    c.start()
    c.wait()
     
execute(main)
os._exit(0)
