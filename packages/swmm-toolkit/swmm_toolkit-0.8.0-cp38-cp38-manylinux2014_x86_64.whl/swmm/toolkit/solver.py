# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Solver Module

"""


from sys import version_info
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_solver', [dirname(__file__)])
        except ImportError:
            import _solver
            return _solver
        if fp is not None:
            try:
                _mod = imp.load_module('_solver', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _solver = swig_import_helper()
    del swig_import_helper
else:
    import _solver
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0


class NodeStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NodeStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NodeStats, name)
    __repr__ = _swig_repr
    __swig_getmethods__["avgDepth"] = _solver.NodeStats_avgDepth_get
    if _newclass:
        avgDepth = _swig_property(_solver.NodeStats_avgDepth_get)
    __swig_getmethods__["maxDepth"] = _solver.NodeStats_maxDepth_get
    if _newclass:
        maxDepth = _swig_property(_solver.NodeStats_maxDepth_get)
    __swig_getmethods__["maxDepthDate"] = _solver.NodeStats_maxDepthDate_get
    if _newclass:
        maxDepthDate = _swig_property(_solver.NodeStats_maxDepthDate_get)
    __swig_getmethods__["maxRptDepth"] = _solver.NodeStats_maxRptDepth_get
    if _newclass:
        maxRptDepth = _swig_property(_solver.NodeStats_maxRptDepth_get)
    __swig_getmethods__["volFlooded"] = _solver.NodeStats_volFlooded_get
    if _newclass:
        volFlooded = _swig_property(_solver.NodeStats_volFlooded_get)
    __swig_getmethods__["timeFlooded"] = _solver.NodeStats_timeFlooded_get
    if _newclass:
        timeFlooded = _swig_property(_solver.NodeStats_timeFlooded_get)
    __swig_getmethods__["timeSurcharged"] = _solver.NodeStats_timeSurcharged_get
    if _newclass:
        timeSurcharged = _swig_property(_solver.NodeStats_timeSurcharged_get)
    __swig_getmethods__["timeCourantCritical"] = _solver.NodeStats_timeCourantCritical_get
    if _newclass:
        timeCourantCritical = _swig_property(_solver.NodeStats_timeCourantCritical_get)
    __swig_getmethods__["totLatFlow"] = _solver.NodeStats_totLatFlow_get
    if _newclass:
        totLatFlow = _swig_property(_solver.NodeStats_totLatFlow_get)
    __swig_getmethods__["maxLatFlow"] = _solver.NodeStats_maxLatFlow_get
    if _newclass:
        maxLatFlow = _swig_property(_solver.NodeStats_maxLatFlow_get)
    __swig_getmethods__["maxInflow"] = _solver.NodeStats_maxInflow_get
    if _newclass:
        maxInflow = _swig_property(_solver.NodeStats_maxInflow_get)
    __swig_getmethods__["maxOverflow"] = _solver.NodeStats_maxOverflow_get
    if _newclass:
        maxOverflow = _swig_property(_solver.NodeStats_maxOverflow_get)
    __swig_getmethods__["maxPondedVol"] = _solver.NodeStats_maxPondedVol_get
    if _newclass:
        maxPondedVol = _swig_property(_solver.NodeStats_maxPondedVol_get)
    __swig_getmethods__["maxInflowDate"] = _solver.NodeStats_maxInflowDate_get
    if _newclass:
        maxInflowDate = _swig_property(_solver.NodeStats_maxInflowDate_get)
    __swig_getmethods__["maxOverflowDate"] = _solver.NodeStats_maxOverflowDate_get
    if _newclass:
        maxOverflowDate = _swig_property(_solver.NodeStats_maxOverflowDate_get)

    def __init__(self):
        """
        Node Statistics

        Attributes
        ----------
        avgDepth: double
            average node depth (level)
        maxDepth: double
            max node depth (level) (from routing step)
        maxDepthDate: DateTime
            date of maximum depth
        maxRptDepth: double
            max node depth (level) (from reporting step)
        volFlooded: double
            total volume flooded (volume)
        timeFlooded: double
            total time flooded
        timeSurcharged: double
            total time surcharged
        timeCourantCritical: double
            total time courant critical
        totLatFlow: double
            total lateral inflow (volume)
        maxLatFlow: double
            maximum lateral inflow (flowrate)
        maxInflow: double
            maximum total inflow (flowrate)
        maxOverflow: double
            maximum flooding (flowrate)
        maxPondedVol: double
            maximum ponded volume (volume)
        maxInflowDate: DateTime
            date of maximum inflow
        maxOverflowDate: DateTime
            date of maximum overflow

        """
        this = _solver.new_NodeStats()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_NodeStats
    __del__ = lambda self: None
NodeStats_swigregister = _solver.NodeStats_swigregister
NodeStats_swigregister(NodeStats)

class StorageStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StorageStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StorageStats, name)
    __repr__ = _swig_repr
    __swig_getmethods__["initVol"] = _solver.StorageStats_initVol_get
    if _newclass:
        initVol = _swig_property(_solver.StorageStats_initVol_get)
    __swig_getmethods__["avgVol"] = _solver.StorageStats_avgVol_get
    if _newclass:
        avgVol = _swig_property(_solver.StorageStats_avgVol_get)
    __swig_getmethods__["maxVol"] = _solver.StorageStats_maxVol_get
    if _newclass:
        maxVol = _swig_property(_solver.StorageStats_maxVol_get)
    __swig_getmethods__["maxFlow"] = _solver.StorageStats_maxFlow_get
    if _newclass:
        maxFlow = _swig_property(_solver.StorageStats_maxFlow_get)
    __swig_getmethods__["evapLosses"] = _solver.StorageStats_evapLosses_get
    if _newclass:
        evapLosses = _swig_property(_solver.StorageStats_evapLosses_get)
    __swig_getmethods__["exfilLosses"] = _solver.StorageStats_exfilLosses_get
    if _newclass:
        exfilLosses = _swig_property(_solver.StorageStats_exfilLosses_get)
    __swig_getmethods__["maxVolDate"] = _solver.StorageStats_maxVolDate_get
    if _newclass:
        maxVolDate = _swig_property(_solver.StorageStats_maxVolDate_get)

    def __init__(self):
        """
        Storage Statistics

        Attributes
        ----------
        initVol: double
            initial volume (volume)
        avgVol: double
            average volume (volume) (from routing step)
        maxVol: double
            maximum volume (volume) (from routing step)
        maxFlow: double
            maximum total inflow (flowrate) (from routing step)
        evapLosses: double
            evaporation losses (volume)
        exfilLosses: double
            exfiltration losses (volume)
        maxVolDate: DateTime
            date of maximum volume

        """
        this = _solver.new_StorageStats()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_StorageStats
    __del__ = lambda self: None
StorageStats_swigregister = _solver.StorageStats_swigregister
StorageStats_swigregister(StorageStats)

class OutfallStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutfallStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OutfallStats, name)
    __repr__ = _swig_repr

    def __init__(self, num_pollut: 'int'):
        """
        Outfall Statistics

        Attributes
        ----------
        avgFlow: double
            average flow (flowrate)
        maxFlow: double
            maximum flow (flowrate) (from routing step)
        totalLoad: double *
            total pollutant load (mass)
        totalPeriods: double
            total simulation steps (from routing step)

        """
        this = _solver.new_OutfallStats(num_pollut)
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_OutfallStats
    __del__ = lambda self: None

    def get_totalLoad(self, index: 'int') -> "double":
        return _solver.OutfallStats_get_totalLoad(self, index)
    __swig_getmethods__["avgFlow"] = _solver.OutfallStats_avgFlow_get
    if _newclass:
        avgFlow = _swig_property(_solver.OutfallStats_avgFlow_get)
    __swig_getmethods__["maxFlow"] = _solver.OutfallStats_maxFlow_get
    if _newclass:
        maxFlow = _swig_property(_solver.OutfallStats_maxFlow_get)
    __swig_getmethods__["totalLoad"] = _solver.OutfallStats_totalLoad_get
    if _newclass:
        totalLoad = _swig_property(_solver.OutfallStats_totalLoad_get)
    __swig_getmethods__["totalPeriods"] = _solver.OutfallStats_totalPeriods_get
    if _newclass:
        totalPeriods = _swig_property(_solver.OutfallStats_totalPeriods_get)
OutfallStats_swigregister = _solver.OutfallStats_swigregister
OutfallStats_swigregister(OutfallStats)

class LinkStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinkStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LinkStats, name)
    __repr__ = _swig_repr
    __swig_getmethods__["maxFlow"] = _solver.LinkStats_maxFlow_get
    if _newclass:
        maxFlow = _swig_property(_solver.LinkStats_maxFlow_get)
    __swig_getmethods__["maxFlowDate"] = _solver.LinkStats_maxFlowDate_get
    if _newclass:
        maxFlowDate = _swig_property(_solver.LinkStats_maxFlowDate_get)
    __swig_getmethods__["maxVeloc"] = _solver.LinkStats_maxVeloc_get
    if _newclass:
        maxVeloc = _swig_property(_solver.LinkStats_maxVeloc_get)
    __swig_getmethods__["maxDepth"] = _solver.LinkStats_maxDepth_get
    if _newclass:
        maxDepth = _swig_property(_solver.LinkStats_maxDepth_get)
    __swig_getmethods__["timeNormalFlow"] = _solver.LinkStats_timeNormalFlow_get
    if _newclass:
        timeNormalFlow = _swig_property(_solver.LinkStats_timeNormalFlow_get)
    __swig_getmethods__["timeInletControl"] = _solver.LinkStats_timeInletControl_get
    if _newclass:
        timeInletControl = _swig_property(_solver.LinkStats_timeInletControl_get)
    __swig_getmethods__["timeSurcharged"] = _solver.LinkStats_timeSurcharged_get
    if _newclass:
        timeSurcharged = _swig_property(_solver.LinkStats_timeSurcharged_get)
    __swig_getmethods__["timeFullUpstream"] = _solver.LinkStats_timeFullUpstream_get
    if _newclass:
        timeFullUpstream = _swig_property(_solver.LinkStats_timeFullUpstream_get)
    __swig_getmethods__["timeFullDnstream"] = _solver.LinkStats_timeFullDnstream_get
    if _newclass:
        timeFullDnstream = _swig_property(_solver.LinkStats_timeFullDnstream_get)
    __swig_getmethods__["timeFullFlow"] = _solver.LinkStats_timeFullFlow_get
    if _newclass:
        timeFullFlow = _swig_property(_solver.LinkStats_timeFullFlow_get)
    __swig_getmethods__["timeCapacityLimited"] = _solver.LinkStats_timeCapacityLimited_get
    if _newclass:
        timeCapacityLimited = _swig_property(_solver.LinkStats_timeCapacityLimited_get)
    __swig_getmethods__["timeInFlowClass"] = _solver.LinkStats_timeInFlowClass_get
    if _newclass:
        timeInFlowClass = _swig_property(_solver.LinkStats_timeInFlowClass_get)
    __swig_getmethods__["timeCourantCritical"] = _solver.LinkStats_timeCourantCritical_get
    if _newclass:
        timeCourantCritical = _swig_property(_solver.LinkStats_timeCourantCritical_get)
    __swig_getmethods__["flowTurns"] = _solver.LinkStats_flowTurns_get
    if _newclass:
        flowTurns = _swig_property(_solver.LinkStats_flowTurns_get)
    __swig_getmethods__["flowTurnSign"] = _solver.LinkStats_flowTurnSign_get
    if _newclass:
        flowTurnSign = _swig_property(_solver.LinkStats_flowTurnSign_get)

    def __init__(self):
        """
        Link Statistics

        .. rubric:: 'Flow Classes'

        ===========   ===========================
        Flow Class    Description                
        ===========   ===========================
        DRY           dry conduit
        UP_DRY        upstream end is dry
        DN_DRY        downstream end is dry
        SUBCRITICAL   sub-critical flow
        SUPCRITICAL   super-critical flow
        UP_CRITICAL   free-fall at upstream end
        DN_CRITICAL   free-fall at downstream end
        ===========   ===========================

        Attributes
        ----------
        maxFlow: double
            maximum flow (flowrate) (from routing step)
        maxFlowDate: double
            date of maximum flowrate
        maxVeloc: double
            maximum velocity (from routing step)
        maxDepth: double
            maximum depth (level)
        timeNormalFlow: double
            time in normal flow
        timeInletControl: double
            time under inlet control
        timeSurcharged: double
            time surcharged
        timeFullUpstream: double
            time full upstream
        timeFullDnstream: double
            time full downstream
        timeFullFlow: double
            time full flow
        timeCapacityLimited: double
            time capacity limited
        timeInFlowClass: double[7]
            time in flow class (See: 'Flow Classes')
        timeCourantCritical: double
            time courant critical
        flowTurns: double
            number of flow turns
        flowTurnSign: double
            number of flow turns sign

        """
        this = _solver.new_LinkStats()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_LinkStats
    __del__ = lambda self: None
LinkStats_swigregister = _solver.LinkStats_swigregister
LinkStats_swigregister(LinkStats)

class PumpStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PumpStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PumpStats, name)
    __repr__ = _swig_repr
    __swig_getmethods__["utilized"] = _solver.PumpStats_utilized_get
    if _newclass:
        utilized = _swig_property(_solver.PumpStats_utilized_get)
    __swig_getmethods__["minFlow"] = _solver.PumpStats_minFlow_get
    if _newclass:
        minFlow = _swig_property(_solver.PumpStats_minFlow_get)
    __swig_getmethods__["avgFlow"] = _solver.PumpStats_avgFlow_get
    if _newclass:
        avgFlow = _swig_property(_solver.PumpStats_avgFlow_get)
    __swig_getmethods__["maxFlow"] = _solver.PumpStats_maxFlow_get
    if _newclass:
        maxFlow = _swig_property(_solver.PumpStats_maxFlow_get)
    __swig_getmethods__["volume"] = _solver.PumpStats_volume_get
    if _newclass:
        volume = _swig_property(_solver.PumpStats_volume_get)
    __swig_getmethods__["energy"] = _solver.PumpStats_energy_get
    if _newclass:
        energy = _swig_property(_solver.PumpStats_energy_get)
    __swig_getmethods__["offCurveLow"] = _solver.PumpStats_offCurveLow_get
    if _newclass:
        offCurveLow = _swig_property(_solver.PumpStats_offCurveLow_get)
    __swig_getmethods__["offCurveHigh"] = _solver.PumpStats_offCurveHigh_get
    if _newclass:
        offCurveHigh = _swig_property(_solver.PumpStats_offCurveHigh_get)
    __swig_getmethods__["startUps"] = _solver.PumpStats_startUps_get
    if _newclass:
        startUps = _swig_property(_solver.PumpStats_startUps_get)
    __swig_getmethods__["totalPeriods"] = _solver.PumpStats_totalPeriods_get
    if _newclass:
        totalPeriods = _swig_property(_solver.PumpStats_totalPeriods_get)

    def __init__(self):
        """
        Pump Statistics

        Attributes
        ----------
        utilized: double
            time utilized
        minFlow: double
            minimum flowrate
        avgFlow: double
            average flowrate
        maxFlow: double
            maximum flowrate
        volume: double
            total pumping volume (volume)
        energy: double
            total energy demand
        offCurveLow: double
            hysteresis low (off depth wrt curve)
        offCurveHigh: double
            hysteresis high (on depth wrt curve)
        startUps: int
            number of start ups
        totalPeriods: int
            total simulation steps (from routing step)

        """
        this = _solver.new_PumpStats()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_PumpStats
    __del__ = lambda self: None
PumpStats_swigregister = _solver.PumpStats_swigregister
PumpStats_swigregister(PumpStats)

class SubcatchStats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SubcatchStats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SubcatchStats, name)
    __repr__ = _swig_repr
    __swig_getmethods__["precip"] = _solver.SubcatchStats_precip_get
    if _newclass:
        precip = _swig_property(_solver.SubcatchStats_precip_get)
    __swig_getmethods__["runon"] = _solver.SubcatchStats_runon_get
    if _newclass:
        runon = _swig_property(_solver.SubcatchStats_runon_get)
    __swig_getmethods__["evap"] = _solver.SubcatchStats_evap_get
    if _newclass:
        evap = _swig_property(_solver.SubcatchStats_evap_get)
    __swig_getmethods__["infil"] = _solver.SubcatchStats_infil_get
    if _newclass:
        infil = _swig_property(_solver.SubcatchStats_infil_get)
    __swig_getmethods__["runoff"] = _solver.SubcatchStats_runoff_get
    if _newclass:
        runoff = _swig_property(_solver.SubcatchStats_runoff_get)
    __swig_getmethods__["maxFlow"] = _solver.SubcatchStats_maxFlow_get
    if _newclass:
        maxFlow = _swig_property(_solver.SubcatchStats_maxFlow_get)
    __swig_getmethods__["impervRunoff"] = _solver.SubcatchStats_impervRunoff_get
    if _newclass:
        impervRunoff = _swig_property(_solver.SubcatchStats_impervRunoff_get)
    __swig_getmethods__["pervRunoff"] = _solver.SubcatchStats_pervRunoff_get
    if _newclass:
        pervRunoff = _swig_property(_solver.SubcatchStats_pervRunoff_get)

    def __init__(self):
        """
        Subcatchment Statistics

        Attributes
        ----------
        precip: double
            total precipication (length)
        runon: double
            total runon (volume)
        evap: double
            total evaporation (volume)
        infil: double
            total infiltration (volume)
        runoff: double
            total runoff (volume)
        maxFlow: double
            maximum runoff rate (flowrate)

        """
        this = _solver.new_SubcatchStats()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_SubcatchStats
    __del__ = lambda self: None
SubcatchStats_swigregister = _solver.SubcatchStats_swigregister
SubcatchStats_swigregister(SubcatchStats)

class RoutingTotals(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RoutingTotals, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RoutingTotals, name)
    __repr__ = _swig_repr
    __swig_getmethods__["dwInflow"] = _solver.RoutingTotals_dwInflow_get
    if _newclass:
        dwInflow = _swig_property(_solver.RoutingTotals_dwInflow_get)
    __swig_getmethods__["wwInflow"] = _solver.RoutingTotals_wwInflow_get
    if _newclass:
        wwInflow = _swig_property(_solver.RoutingTotals_wwInflow_get)
    __swig_getmethods__["gwInflow"] = _solver.RoutingTotals_gwInflow_get
    if _newclass:
        gwInflow = _swig_property(_solver.RoutingTotals_gwInflow_get)
    __swig_getmethods__["iiInflow"] = _solver.RoutingTotals_iiInflow_get
    if _newclass:
        iiInflow = _swig_property(_solver.RoutingTotals_iiInflow_get)
    __swig_getmethods__["exInflow"] = _solver.RoutingTotals_exInflow_get
    if _newclass:
        exInflow = _swig_property(_solver.RoutingTotals_exInflow_get)
    __swig_getmethods__["flooding"] = _solver.RoutingTotals_flooding_get
    if _newclass:
        flooding = _swig_property(_solver.RoutingTotals_flooding_get)
    __swig_getmethods__["outflow"] = _solver.RoutingTotals_outflow_get
    if _newclass:
        outflow = _swig_property(_solver.RoutingTotals_outflow_get)
    __swig_getmethods__["evapLoss"] = _solver.RoutingTotals_evapLoss_get
    if _newclass:
        evapLoss = _swig_property(_solver.RoutingTotals_evapLoss_get)
    __swig_getmethods__["seepLoss"] = _solver.RoutingTotals_seepLoss_get
    if _newclass:
        seepLoss = _swig_property(_solver.RoutingTotals_seepLoss_get)
    __swig_getmethods__["reacted"] = _solver.RoutingTotals_reacted_get
    if _newclass:
        reacted = _swig_property(_solver.RoutingTotals_reacted_get)
    __swig_getmethods__["initStorage"] = _solver.RoutingTotals_initStorage_get
    if _newclass:
        initStorage = _swig_property(_solver.RoutingTotals_initStorage_get)
    __swig_getmethods__["finalStorage"] = _solver.RoutingTotals_finalStorage_get
    if _newclass:
        finalStorage = _swig_property(_solver.RoutingTotals_finalStorage_get)
    __swig_getmethods__["pctError"] = _solver.RoutingTotals_pctError_get
    if _newclass:
        pctError = _swig_property(_solver.RoutingTotals_pctError_get)

    def __init__(self):
        """
        System Flow Routing Totals

        Attributes
        ----------
        dwInflow: double
            dry weather inflow
        wwInflow: double
            wet weather inflow
        gwInflow: double
            groundwater inflow
        iiInflow: double
            RDII inflow
        exInflow: double
            direct inflow
        flooding: double
            internal flooding
        outflow: double
            external outflow
        evapLoss: double
            evaporation loss
        seepLoss: double
            seepage loss
        reacted: double
            reaction losses
        initStorage: double
            initial storage volume
        finalStorage: double
            final storage volume
        pctError: double
            continuity error

        """
        this = _solver.new_RoutingTotals()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_RoutingTotals
    __del__ = lambda self: None
RoutingTotals_swigregister = _solver.RoutingTotals_swigregister
RoutingTotals_swigregister(RoutingTotals)

class RunoffTotals(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RunoffTotals, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RunoffTotals, name)
    __repr__ = _swig_repr
    __swig_getmethods__["rainfall"] = _solver.RunoffTotals_rainfall_get
    if _newclass:
        rainfall = _swig_property(_solver.RunoffTotals_rainfall_get)
    __swig_getmethods__["evap"] = _solver.RunoffTotals_evap_get
    if _newclass:
        evap = _swig_property(_solver.RunoffTotals_evap_get)
    __swig_getmethods__["infil"] = _solver.RunoffTotals_infil_get
    if _newclass:
        infil = _swig_property(_solver.RunoffTotals_infil_get)
    __swig_getmethods__["runoff"] = _solver.RunoffTotals_runoff_get
    if _newclass:
        runoff = _swig_property(_solver.RunoffTotals_runoff_get)
    __swig_getmethods__["drains"] = _solver.RunoffTotals_drains_get
    if _newclass:
        drains = _swig_property(_solver.RunoffTotals_drains_get)
    __swig_getmethods__["runon"] = _solver.RunoffTotals_runon_get
    if _newclass:
        runon = _swig_property(_solver.RunoffTotals_runon_get)
    __swig_getmethods__["initStorage"] = _solver.RunoffTotals_initStorage_get
    if _newclass:
        initStorage = _swig_property(_solver.RunoffTotals_initStorage_get)
    __swig_getmethods__["finalStorage"] = _solver.RunoffTotals_finalStorage_get
    if _newclass:
        finalStorage = _swig_property(_solver.RunoffTotals_finalStorage_get)
    __swig_getmethods__["initSnowCover"] = _solver.RunoffTotals_initSnowCover_get
    if _newclass:
        initSnowCover = _swig_property(_solver.RunoffTotals_initSnowCover_get)
    __swig_getmethods__["finalSnowCover"] = _solver.RunoffTotals_finalSnowCover_get
    if _newclass:
        finalSnowCover = _swig_property(_solver.RunoffTotals_finalSnowCover_get)
    __swig_getmethods__["snowRemoved"] = _solver.RunoffTotals_snowRemoved_get
    if _newclass:
        snowRemoved = _swig_property(_solver.RunoffTotals_snowRemoved_get)
    __swig_getmethods__["pctError"] = _solver.RunoffTotals_pctError_get
    if _newclass:
        pctError = _swig_property(_solver.RunoffTotals_pctError_get)

    def __init__(self):
        """
        System Runoff Totals

        Attributes
        ----------
        rainfall: double
            rainfall total (depth)
        evap: double
            evaporation loss (volume)
        infil: double
            infiltration loss (volume)
        runoff: double
            runoff volume (volume)
        drains: double
            LID drains (volume)
        runon: double
            runon from outfalls (volume)
        initStorage: double
            inital surface storage (depth)
        finalStorage: double
            final surface storage (depth)
        initSnowCover: double
            initial snow cover (depth)
        finalSnowCover: double
            final snow cover (depth)
        snowRemoved: double
            snow removal (depth)
        pctError: double
            continuity error (%)

        """
        this = _solver.new_RunoffTotals()
        try:
            self.this.append(this)
        except Exception:
            self.this = this
    __swig_destroy__ = _solver.delete_RunoffTotals
    __del__ = lambda self: None
RunoffTotals_swigregister = _solver.RunoffTotals_swigregister
RunoffTotals_swigregister(RunoffTotals)


def swmm_run(f1: 'char const *', f2: 'char const *', f3: 'char const *') -> "int":
    """
    Opens SWMM input file, reads in network data, runs, and closes

    Parameters
    ----------
    f1: char const *
        pointer to name of input file (must exist)
    f2: char const *
        pointer to name of report file (to be created)
    f3: char const *
        pointer to name of binary output file (to be created)

    """
    return _solver.swmm_run(f1, f2, f3)

def swmm_open(f1: 'char const *', f2: 'char const *', f3: 'char const *') -> "int":
    """
    Opens SWMM input file & reads in network data

    Parameters
    ----------
    f1: char const *
        pointer to name of input file (must exist)
    f2: char const *
        pointer to name of report file (to be created)
    f3: char const *
        pointer to name of binary output file (to be created)

    """
    return _solver.swmm_open(f1, f2, f3)

def swmm_start(saveFlag: 'int') -> "int":
    """
    Start SWMM simulation

    Parameters
    ----------
    saveFlag: int
        TRUE or FALSE to save timeseries to report file

    """
    return _solver.swmm_start(saveFlag)

def swmm_step() -> "double *":
    """
    Step SWMM simulation forward

    Returns
    -------
    elapsedTime: double
        elapsed simulation time [milliseconds]

    """
    return _solver.swmm_step()

def swmm_end() -> "int":
    """
    End SWMM simulation   

    """
    return _solver.swmm_end()

def swmm_report() -> "int":
    """
    Write text report file

    """
    return _solver.swmm_report()

def swmm_get_mass_balance() -> "float *, float *, float *":
    """
    Get routing errors

    Returns
    -------
    runoffErr: float *
        Runoff routing error
    flowErr: float * 
        Flow routing error
    qualErr: float * 
        Quality routing error

    """
    return _solver.swmm_get_mass_balance()

def swmm_close() -> "int":
    """
    Frees all memory and files used by SWMM

    """
    return _solver.swmm_close()

def swmm_get_version() -> "int":
    """
    Get Legacy SWMM version number

    Returns
    -------
    version: int
        Version number

    """
    return _solver.swmm_get_version()

def swmm_version_info() -> "char **, char **, char **":
    """
    Get full semantic version number info

    Returns
    -------
    major: char ** 
        sematic version major number
    minor: char ** 
        sematic version minor number
    patch: char ** 
        sematic version patch number

    """
    return _solver.swmm_version_info()

def project_get_index(type: 'SM_ObjectType', id: 'char *') -> "int *":
    """
    Finds the index of an object given its ID.

    Parameters
    ----------
    type: SM_ObjectType
        type An object type (see :ref: SM_ObjectType)
    id: char *
        id The object ID

    Returns
    -------    
    index: int *
        The objects index

    """
    return _solver.project_get_index(type, id)

def simulation_get_unit(type: 'SM_Units') -> "int *":
    """
    Gets Simulation Unit

    Parameters
    ----------
    type: SM_Units
        Option code (see :ref: SM_Units)

    Returns
    -------
    value: int *
        Option value

    """
    return _solver.simulation_get_unit(type)

def simulation_get_setting(type: 'SM_SimOption') -> "int *":
    """
    Gets Simulation Analysis Setting

    Parameters
    ----------
    type: SM_SimOption
        Option code (see :ref: SM_SimOption)

    Returns
    -------
    value: int *
        Option value

    """
    return _solver.simulation_get_setting(type)

def simulation_get_parameter(type: 'SM_SimSetting') -> "double *":
    """
    Gets Simulation Analysis Setting

    Parameters
    ----------
    type: SM_SimSetting
        Option code (see :ref: SM_SimSetting)

    Returns
    -------
    value: double *
        Option value

    """
    return _solver.simulation_get_parameter(type)

def project_get_count(type: 'SM_ObjectType') -> "int *":
    """
    Gets Object Count

    Parameters
    ----------
    type: SM_ObjectType
        Option code (see :ref: SM_ObjectType)

    Returns
    -------
    count: int *
        Option value

    """
    return _solver.project_get_count(type)

def project_get_id(type: 'SM_ObjectType', index: 'int') -> "char **":
    """
    Gets Object ID

    Parameters
    ----------
    type: SM_ObjectType
        type Option code (see :ref: SM_ObjectType)
    index: int
        index of the Object

    Returns
    -------
    id: char **
        The string ID of object.

    """
    return _solver.project_get_id(type, index)

def node_get_type(index: 'int') -> "SM_NodeType *":
    """
    Get the type of node with specified index.

    Parameters
    ----------
    index: int
        The index of a node

    Returns
    -------
    Ntype: SM_NodeType *
        The type code for the node (:ref: SM_NodeType). 
        id must be pre-allocated by the caller.

    """
    return _solver.node_get_type(index)

def link_get_type(index: 'int') -> "SM_LinkType *":
    """
    Get the type of link with specified index.

    Parameters
    ----------
    index: int
        The index of a link

    Returns
    -------
    Ltype: SM_LinkType *
        The type code for the link (:ref: SM_LinkType).

    """
    return _solver.link_get_type(index)

def link_get_connections(index: 'int') -> "int *, int *":
    """
    Get the link Connection Node Indeces. If the conduit has a negative slope, 
    the dynamic wave solver will automatically reverse the nodes. 

    Parameters
    ----------
    index: int
        The index of a link

    Returns
    -------
    Node1: int *
        The upstream node index.
    Node2: int *
        The downstream node index.

    """
    return _solver.link_get_connections(index)

def link_get_direction(index: 'int') -> "signed char *":
    """
    Get the link flow direction

    Parameters
    ----------
    index: int
        The index of a link

    Returns
    -------
    value: char *
        The link flow direction.

    """
    return _solver.link_get_direction(index)

def subcatch_get_connection(index: 'int') -> "SM_ObjectType *, int *":
    """
    Get the Subcatchment connection. Subcatchments can load to a node, another 
    subcatchment, or itself.

    Parameters
    ----------
    index: int
        The index of a Subcatchment

    Returns
    -------
    type: SM_ObjectType
        The type of object loading (See :ref: SM_ObjectType)
    out_index: int *
        The object index

    """
    return _solver.subcatch_get_connection(index)

def lid_usage_get_count(index: 'int') -> "int *":
    """
    Get the number of lid units on a subcatchment.

    Parameters
    ----------
    index: int
        The index of a subcatchment

    Returns
    -------
    value: int *
        The number of lid units on a subcatchment

    """
    return _solver.lid_usage_get_count(index)

def lid_usage_get_parameter(index: 'int', lidIndex: 'int', param: 'SM_LidUProperty') -> "double *":
    """
    Get a property value for a specified lid unit on a specified subcatchment

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    param: SM_LidUProperty
        The property type code (See :ref: SM_LidUProperty)

    Returns
    -------
    value: double
        The value of the lid unit's property

    """
    return _solver.lid_usage_get_parameter(index, lidIndex, param)

def lid_usage_set_parameter(index: 'int', lidIndex: 'int', param: 'SM_LidUProperty', value: 'double') -> "int":
    """
    Set a property value for a specified lid unit on a specified subcatchment

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    param: SM_LidUProperty
        The property type code (See :ref: SM_LidUProperty)
    value: double
        The new value of the lid unit's property

    """
    return _solver.lid_usage_set_parameter(index, lidIndex, param, value)

def lid_usage_get_option(index: 'int', lidIndex: 'int', param: 'SM_LidUOptions') -> "int *":
    """
    Get the lid option for a specified lid unit on a specified subcatchment

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    param: SM_LidUOptions
        The lid option type code (See :ref: SM_LidUOptions)

    Returns
    -------
    value: int *
        The value of the option for the lid unit

    """
    return _solver.lid_usage_get_option(index, lidIndex, param)

def lid_usage_set_option(index: 'int', lidIndex: 'int', param: 'SM_LidUOptions', value: 'int') -> "int":
    """
    Set the lid option for a specified lid unit on a specified subcatchment

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    param: SM_LidUOptions
        The lid option type code (See :ref: SM_LidUOptions)
    value: int
        The new value of the option for the lid unit

    """
    return _solver.lid_usage_set_option(index, lidIndex, param, value)

def lid_control_get_overflow(lidControlIndex: 'int') -> "int *":
    """
    Get the lid control surface immediate overflow condition

    Parameters
    ----------
    lidControlIndex: int
        The index of specified lid control

    Returns
    -------
    condition: int *
        The value of surface immediate overflow condition

    """
    return _solver.lid_control_get_overflow(lidControlIndex)

def lid_control_get_parameter(lidControlIndex: 'int', layerIndex: 'SM_LidLayer', param: 'SM_LidLayerProperty') -> "double *":
    """
    Get a property value for specified lid control

    Parameters
    ----------
    lidControlIndex: int
        The index of specified lid control
    layerIndex: SM_LidLayer
        The index of specified lid layer (See :ref: SM_LidLayer)
    param: SM_LidLayerProperty
        The property type code (See :ref: SM_LidLayerProperty)

    Returns
    -------
    value: double 
        The value of lid control's property

    """
    return _solver.lid_control_get_parameter(lidControlIndex, layerIndex, param)

def lid_control_set_parameter(lidControlIndex: 'int', layerIndex: 'SM_LidLayer', param: 'SM_LidLayerProperty', value: 'double') -> "int":
    """
    Set a property value for specified lid control

    Parameters
    ----------
    lidControlIndex: int
        The index of specified lid control
    layerIndex: SM_LidLayer
        The index of specified lid layer (See :ref: SM_LidLayer)
    param: SM_LidLayerProperty
        The property type code (See :ref: SM_LidLayerProperty)
    value: double
        The new value for the lid control's property

    """
    return _solver.lid_control_set_parameter(lidControlIndex, layerIndex, param, value)

def lid_usage_get_flux_rate(index: 'int', lidIndex: 'int', layerIndex: 'SM_LidLayer') -> "double *":
    """
    Get the lid unit water balance simulated value at current time

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    layerIndex: SM_LidLayer
        The index of specified lid layer (See :ref: SM_LidLayer)

    Returns
    -------
    result: double * 
        The result for the specified lid unit

    """
    return _solver.lid_usage_get_flux_rate(index, lidIndex, layerIndex)

def lid_group_get_result(index: 'int', type: 'SM_LidResult') -> "double *":
    """
    Get the lid group of a specified subcatchment result at current time

    Parameters
    ----------
    index: int
        The index of a subcatchment
    type: SM_LidResult
        The result type code (See :ref: SM_LidResult)

    Returns
    -------
    result: double *
        The result for the specified lid group

    """
    return _solver.lid_group_get_result(index, type)

def lid_usage_get_result(index: 'int', lidIndex: 'int', type: 'SM_LidResult') -> "double *":
    """
    Get the lid unit of a specified subcatchment result at current time

    Parameters
    ----------
    index: int
        The index of a subcatchment
    lidIndex: int
        The index of specified lid unit
    type: SM_LidResult
        The result type code (See :ref: SM_LidResult)

    Returns
    -------
    result: double *
        The result for the specified lid unit

    """
    return _solver.lid_usage_get_result(index, lidIndex, type)

def node_get_parameter(index: 'int', param: 'SM_NodeProperty') -> "double *":
    """
    Get a property value for specified node.

    Parameters
    ----------
    index: int
        The index of a node
    param: SM_NodeProperty
        The property type code (See :ref: SM_NodeProperty)

    Returns
    -------
    value: double *
        The value of the node's property

    """
    return _solver.node_get_parameter(index, param)

def node_set_parameter(index: 'int', param: 'SM_NodeProperty', value: 'double') -> "int":
    """
    Set a property value for specified node.

    Parameters
    ----------
    index: int
        The index of a node
    param: SM_NodeProperty
        The property type code (See :ref: SM_NodeProperty)
    value: double
        The new value of the node's property

    """
    return _solver.node_set_parameter(index, param, value)

def link_get_parameter(index: 'int', param: 'SM_LinkProperty') -> "double *":
    """
    Get a property value for specified link.

    Parameters
    ----------
    index: int
        The index of a link
    param: SM_LinkProperty
        The property type code (See :ref: SM_LinkProperty)

    Returns
    -------
    value: double *
        The value of the link's property

    """
    return _solver.link_get_parameter(index, param)

def link_set_parameter(index: 'int', param: 'SM_LinkProperty', value: 'double') -> "int":
    """
    Set a property value for specified link.

    Parameters
    ----------
    index: int
        The index of a link
    param: SM_LinkProperty
        The property type code (See :ref: SM_LinkProperty)
    value: double
        The new value of the link's property

    """
    return _solver.link_set_parameter(index, param, value)

def subcatch_get_parameter(index: 'int', param: 'SM_SubcProperty') -> "double *":
    """
    Get a property value for specified subcatchment.

    Parameters
    ----------
    index: int
        The index of a subcatchment
    param: SM_SubcProperty
        The property type code (See :ref: SM_SubcProperty)

    Returns
    -------
    value: double *
        The value of the subcatchment's property

    """
    return _solver.subcatch_get_parameter(index, param)

def subcatch_set_parameter(index: 'int', param: 'SM_SubcProperty', value: 'double') -> "int":
    """
    Set a property value for specified subcatchment.

    Parameters
    ----------
    index: int
        The index of a subcatchment
    param: SM_SubcProperty
        The property type code (See :ref: SM_SubcProperty)
    value: double
        The new value of the subcatchment's property

    """
    return _solver.subcatch_set_parameter(index, param, value)

def simulation_get_datetime(type: 'SM_TimePropety') -> "int *, int *, int *, int *, int *, int *":
    """
    Get the simulation datetime information

    Parameters
    ----------
    type: SM_TimePropety
        The property type code (See :ref: SM_TimePropety)

    Returns
    -------
    year: int *
        The year
    month: int *
        The month
    day: int *
        The day
    hour: int *
        The hour
    minute: int *
        The minute
    second: int *
        The seconds

    """
    return _solver.simulation_get_datetime(type)

def simulation_set_datetime(type: 'SM_TimePropety', year: 'int', month: 'int', day: 'int', hour: 'int', minute: 'int', second: 'int') -> "int":
    """
    Set simulation datetime information.

    Parameters
    ----------
    type: SM_TimePropety 
        type The property type code (See :ref: SM_TimePropety)
    year: int
        The year
    month: int
        The month
    day: int
        The day
    hour: int
        The hour
    minute: int
        The minute
    second: int
        The seconds

    """
    return _solver.simulation_set_datetime(type, year, month, day, hour, minute, second)

def simulation_get_current_datetime() -> "int *, int *, int *, int *, int *, int *":
    """
    Get the current simulation datetime information.

    Returns
    -------
    year: int *
        The year
    month: int *
        The month
    day: int *
        The day
    hour: int *
        The hour
    minute: int *
        The minute
    second: int *
        The seconds

    """
    return _solver.simulation_get_current_datetime()

def node_get_result(index: 'int', type: 'SM_NodeResult') -> "double *":
    """
    Get a result value for specified node.

    Parameters
    ----------
    index: int
        The index of a node
    type: SM_NodeResult
        The property type code (See :ref: SM_NodeResult)

    Returns
    -------
    result: double *
        The result of the node's property

    """
    return _solver.node_get_result(index, type)

def node_get_pollutant(index: 'int', type: 'SM_NodePollut') -> "int *":
    """
    Gets pollutant values for a specified node.

    Parameters
    ----------
    index: int
        The index of a node
    type: SM_NodePollut
        The property type code (see :ref: SM_NodePollut)

    Returns
    -------
    PollutArray: double *
        result array

    """
    return _solver.node_get_pollutant(index, type)

def link_get_result(index: 'int', type: 'SM_LinkResult') -> "double *":
    """
    Get a result value for specified link.

    Parameters
    ----------
    index: int
        The index of a link
    type: SM_LinkResult
        The property type code (See :ref: SM_LinkResult)

    Returns
    -------
    result: double *
        The result of the link's property

    """
    return _solver.link_get_result(index, type)

def link_get_pollutant(index: 'int', type: 'SM_LinkPollut') -> "int *":
    """
    Gets pollutant values for a specified link.

    Parameters
    ----------
    index: int
        The index of a link
    type: SM_LinkPollut
        The property type code (see :ref: SM_LinkPollut)

    Returns
    -------
    PollutArray: double *
        result array

    """
    return _solver.link_get_pollutant(index, type)

def subcatch_get_result(index: 'int', type: 'SM_SubcResult') -> "double *":
    """
    Get a result value for specified subcatchment.

    Parameters
    ----------
    index: int
        The index of a subcatchment
    type: SM_SubcResult
        The property type code (See :ref: SM_SubcResult)

    Returns
    -------
    result: double *
        The result of the subcatchment's property

    """
    return _solver.subcatch_get_result(index, type)

def subcatch_get_pollutant(index: 'int', type: 'SM_SubcPollut') -> "int *":
    """
    Gets pollutant values for a specified subcatchment.

    Parameters
    ----------
    index: int
        The index of a subcatchment
    type: SM_SubcPollut
        The property type code (see :ref: SM_SubcPollut)

    Returns
    -------
    PollutArray: double **
        result array

    """
    return _solver.subcatch_get_pollutant(index, type)

def raingage_get_precipitation(index: 'int', type: 'SM_GagePrecip') -> "double *":
    """
    Get precipitation rates for a gage.

    Parameters
    ----------
    index: int
        The index of gage
    type: SM_GagePrecip
        The property type code (see :ref: SM_GagePrecip)

    Returns
    -------
    GageArray: double *
        precipitation rate

    """
    return _solver.raingage_get_precipitation(index, type)

def node_get_stats(index: 'int') -> "SM_NodeStats *":
    """
    Get a node statistics.

    Parameters
    ----------
    index: int
        The index of a node

    Returns
    -------
    nodeStats: SM_NodeStats * 
        The Node Stats struct (see :ref: SM_NodeStats) pre-allocated by the caller.

    """
    return _solver.node_get_stats(index)

def node_get_total_inflow(index: 'int') -> "double *":
    """
    Get the cumulative inflow for a node.

    Parameters
    ----------
    index: int
        The index of a node

    Returns
    -------
    value: double *
        The total inflow.

    """
    return _solver.node_get_total_inflow(index)

def storage_get_stats(index: 'int') -> "SM_StorageStats *":
    """
    Get a storage statistics.

    Parameters
    ----------
    index: int
        The index of a storage node

    Returns
    -------
    storageStats: SM_StorageStats * 
        The storage Stats struct (see :ref: SM_StorageStats) pre-allocated by the caller.

    """
    return _solver.storage_get_stats(index)

def outfall_get_stats(index: 'int') -> "SM_OutfallStats *":
    """
    Get outfall statistics.

    Parameters
    ----------
    index: int
        The index of a outfall node

    Returns
    -------
    outfallStats: SM_OutfallStats * 
        The outfall Stats struct (see :ref: SM_OutfallStats).
        pre-allocated by the caller. Caller is also responsible for freeing the
        SM_OutfallStats structure using swmm_freeOutfallStats(). This frees any
        pollutants array.

    """
    return _solver.outfall_get_stats(index)

def link_get_stats(index: 'int') -> "SM_LinkStats *":
    """
    Get link statistics.

    Parameters
    ----------
    index: int
        The link index.

    Returns
    -------
    linkStats: SM_LinkStats *
        The link Stats struct (see :ref: SM_LinkStats). pre-allocated by the caller.

    """
    return _solver.link_get_stats(index)

def pump_get_stats(index: 'int') -> "SM_PumpStats *":
    """
    Get pump statistics.

    Parameters
    ----------
    index: int
        The index of a pump

    Returns
    -------
    pumpStats: SM_PumpStats *
        The link Stats struct (see :ref: SM_PumpStats). pre-allocated by the caller.

    """
    return _solver.pump_get_stats(index)

def subcatch_get_stats(index: 'int') -> "SM_SubcatchStats *":
    """
    Get subcatchment statistics.

    Parameters
    ----------
    index: int
        The index of a subcatchment

    Returns
    -------
    subcatchStats: SM_SubcatchStats *
        The link Stats struct (see :ref: SM_SubcatchStats).
        pre-allocated by the caller. Caller is also responsible for freeing the
        SM_SubcatchStats structure using swmm_freeSubcatchStats(). This frees any
        pollutants array.

    """
    return _solver.subcatch_get_stats(index)

def system_get_routing_totals() -> "SM_RoutingTotals *":
    """
    Get system routing totals.

    Returns
    -------
    routingTot: SM_RoutingTotals *
        The system Routing Stats struct (see :ref: SM_RoutingTotals).
        pre-allocated by the caller.

    """
    return _solver.system_get_routing_totals()

def system_get_runoff_totals() -> "SM_RunoffTotals *":
    """
    Get system runoff totals.

    Returns
    -------
    runoffTot: SM_RunoffTotals *
        The system Runoff Stats struct (see :ref: SM_RunoffTotals).
        pre-allocated by the caller.

    """
    return _solver.system_get_runoff_totals()

def link_set_target_setting(index: 'int', setting: 'double') -> "int":
    """
    Set a link setting (pump, orifice, or weir). Setting for an orifice and a 
    weir should be [0, 1]. A setting for a pump can range from [0, inf). However, 
    if a pump is set to 1, it will pump at its maximum curve setting.

    Parameters
    ----------
    index: int
        The link index.
    setting: double
        The new setting for the link.

    """
    return _solver.link_set_target_setting(index, setting)

def node_set_total_inflow(index: 'int', flowrate: 'double') -> "int":
    """
    Set an inflow rate to a node. The inflow rate is held constant until the 
    caller changes it.

    Parameters
    ----------
    index: int
        The node index.
    flowrate: double
        The new node inflow rate.

    """
    return _solver.node_set_total_inflow(index, flowrate)

def outfall_set_stage(index: 'int', stage: 'double') -> "int":
    """
    Set outfall stage.

    Parameters
    ----------
    index: int
        The outfall node index.
    stage: double
        The outfall node stage (head).

    """
    return _solver.outfall_set_stage(index, stage)

def raingage_set_precipitation(index: 'int', total_precip: 'double') -> "int":
    """
    Set a total precipitation intensity to the gage.

    Parameters
    ----------
    index: int
        The gage index.
    total_precip: double
        The new total precipitation intensity.

    """
    return _solver.raingage_set_precipitation(index, total_precip)
# This file is compatible with both classic and new-style classes.

cvar = _solver.cvar

