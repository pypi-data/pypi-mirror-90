{"version":3,"sources":["Webcam.tsx","index.tsx"],"names":["WebcamRequestState","Webcam","state","onGotMediaStream","mediaStream","imageCapture","getVideoTracks","length","videoDevice","imgCaptureClass","window","setState","requireFeature","name","featurePolicy","document","allowsFeature","Error","assignMediaStream","video","srcObject","play","catch","err","console","warn","toString","render","requestState","webcamRequestState","SUCCESS","onClick","captureFrame","disabled","props","ref","height","FAILURE","mediaStreamErr","grabFrame","then","renderBitmap","imageData","data","width","Array","from","Streamlit","setComponentValue","error","navigator","mediaDevices","this","constraints","audio","getUserMedia","PENDING","StreamlitComponentBase","bitmap","canvas","body","appendChild","createElement","context","getContext","clearRect","drawImage","getImageData","removeChild","withStreamlitConnection","ReactDOM","StrictMode","getElementById"],"mappings":"0LAYKA,E,qGAAAA,K,kBAAAA,E,kBAAAA,E,mBAAAA,M,SAMCC,E,4MACGC,MAAe,G,EAmCdC,iBAAmB,SAACC,GAE1B,IAAIC,EAAe,KACnB,GAAID,EAAYE,iBAAiBC,OAAS,EAAG,CAC3C,IAAMC,EAAcJ,EAAYE,iBAAiB,GAEjDD,EAAe,IAAII,EADMC,OAAD,cACWF,GAErC,EAAKG,SAAS,CAAEP,cAAaC,kB,EAOvBO,eAAiB,SAACC,GAGxB,IAAMC,EAAiBC,SAAD,cACtB,GAAqB,MAAjBD,IAICA,EAAcE,cAAcH,GAC/B,MAAM,IAAII,MAAJ,WAAcJ,EAAd,mC,EAcFK,kBAAoB,SAACC,GACd,MAATA,GAA2C,MAA1B,EAAKjB,MAAME,cAC9Be,EAAMC,UAAY,EAAKlB,MAAME,YAC7Be,EAAME,OAAOC,OAAM,SAAAC,GAAG,OAAIC,QAAQC,KAAR,8BAAoCF,EAAIG,kB,EAI/DC,OAAS,WACd,IAAMC,EAAe,EAAKC,mBAC1B,OAAID,IAAiB5B,EAAmB8B,QAEpC,6BACE,4BAAQC,QAAS,EAAKC,aAAcC,SAAU,EAAKC,MAAMD,UAAuC,MAA3B,EAAK/B,MAAMG,cAAhF,iBAGA,2BAAO8B,IAAK,EAAKjB,kBAAmBkB,OAAQ,OAK9CR,IAAiB5B,EAAmBqC,QAC/B,8CAAoB,EAAKnC,MAAMoC,eAAeZ,YAGhD,sD,EAGDM,aAAe,WACU,MAA3B,EAAK9B,MAAMG,aAKf,EAAKH,MAAMG,aAAakC,YACrBC,KAAKC,GACLD,MAAK,SAAAE,GACJ,IAAMC,EAAO,CACXC,MAAOF,EAAUE,MACjBR,OAAQM,EAAUN,OAClBO,KAAME,MAAMC,KAAKJ,EAAUC,OAE7BI,IAAUC,kBAAkBL,MAE7BrB,OAAM,SAAAC,GACLC,QAAQyB,MAAR,8BAAqC1B,EAAIG,gBAf3CF,QAAQC,KAAK,gD,kEApGW,IAAD,OAIzB,GAHA,0EAG8B,MAA1ByB,UAAUC,aAAd,CAUA,IAEIC,KAAKxC,eAAe,UAKtB,MAAOW,GAEP,YADA6B,KAAKzC,SAAS,CAAE2B,eAAgBf,IAKlC,IAAM8B,EAAsC,CAAEC,OAlBhC,EAkBuCnC,OAjBvC,GAkBd+B,UAAUC,aAAaI,aAAaF,GACjCb,KAAKY,KAAKjD,kBACVmB,OAAM,SAAAC,GAAG,OAAI,EAAKZ,SAAS,CAAE2B,eAAgBf,YAzB9C6B,KAAKzC,SAAS,CAAE2B,eAAgB,2D,yCAyDlC,OAAiC,MAA7Bc,KAAKlD,MAAMoC,eACNtC,EAAmBqC,QACS,MAA1Be,KAAKlD,MAAME,YACbJ,EAAmB8B,QAErB9B,EAAmBwD,Y,GAtETC,KA4HrB,SAAShB,EAAaiB,GAGpB,IAAMC,EAAS5C,SAAS6C,KAAKC,YAAY9C,SAAS+C,cAAc,WAChE,IACEH,EAAOf,MAAQc,EAAOd,MACtBe,EAAOvB,OAASsB,EAAOtB,OAEvB,IAAI2B,EAAUJ,EAAOK,WAAW,MAChC,GAAe,MAAXD,EACF,MAAM,IAAI9C,MAAM,yCAKlB,OAFA8C,EAAQE,UAAU,EAAG,EAAGN,EAAOf,MAAOe,EAAOvB,QAC7C2B,EAAQG,UAAUR,EAAQ,EAAG,GACtBK,EAAQI,aAAa,EAAG,EAAGR,EAAOf,MAAOe,EAAOvB,QAXzD,QAaErB,SAAS6C,KAAKQ,YAAYT,IASfU,kBAAwBpE,GCpKvCqE,IAAS3C,OACP,kBAAC,IAAM4C,WAAP,KACE,kBAAC,EAAD,OAEFxD,SAASyD,eAAe,W","file":"static/js/main.28042bf7.chunk.js","sourcesContent":["// ImageCapture polyfill for Safari\nimport \"image-capture\"\nimport React, { ReactNode } from \"react\"\nimport { Streamlit, StreamlitComponentBase, withStreamlitConnection } from \"streamlit-component-lib\"\n\ninterface State {\n  mediaStream?: MediaStream\n  mediaStreamErr?: any\n  imageCapture?: ImageCapture\n  imageBitmap?: ImageBitmap\n}\n\nenum WebcamRequestState {\n  PENDING = \"pending\",\n  SUCCESS = \"success\",\n  FAILURE = \"failure\",\n}\n\nclass Webcam extends StreamlitComponentBase<State> {\n  public state: State = {}\n\n  public componentDidMount() {\n    super.componentDidMount()\n\n    // We won't have access to mediaDevices when running in http (except on localhost).\n    if (navigator.mediaDevices == null) {\n      this.setState({ mediaStreamErr: \"Can't access MediaDevices. Are you running in https?\"})\n      return\n    }\n\n    const audio = false\n    const video = true\n\n    // If this browser supports querying the 'featurePolicy', check that\n    // we support the requested features.\n    try {\n      if (video) {\n        this.requireFeature(\"camera\")\n      }\n      if (audio) {\n        this.requireFeature(\"microphone\")\n      }\n    } catch (err) {\n      this.setState({ mediaStreamErr: err })\n      return\n    }\n\n    // Request a media stream that fulfills our constraints.\n    const constraints: MediaStreamConstraints = { audio, video }\n    navigator.mediaDevices.getUserMedia(constraints)\n      .then(this.onGotMediaStream)\n      .catch(err => this.setState({ mediaStreamErr: err }))\n  }\n\n  private onGotMediaStream = (mediaStream: MediaStream): void => {\n    // Extract the video track.\n    let imageCapture = null\n    if (mediaStream.getVideoTracks().length > 0) {\n      const videoDevice = mediaStream.getVideoTracks()[0]\n      const imgCaptureClass = (window as any)[\"ImageCapture\"]\n      imageCapture = new imgCaptureClass(videoDevice)\n    }\n    this.setState({ mediaStream, imageCapture })\n  }\n\n  /**\n   * Throw an error if the feature with the given name is not in our document's\n   * featurePolicy.\n   */\n  private requireFeature = (name: string): void => {\n    // We may not be able to access `featurePolicy` - Safari doesn't support\n    // accessing it, for example. In this case, the function is a no-op.\n    const featurePolicy = (document as any)[\"featurePolicy\"]\n    if (featurePolicy == null) {\n      return\n    }\n\n    if (!featurePolicy.allowsFeature(name)) {\n      throw new Error(`'${name}' is not in our featurePolicy`)\n    }\n  }\n\n  private get webcamRequestState(): WebcamRequestState {\n    if (this.state.mediaStreamErr != null) {\n      return WebcamRequestState.FAILURE\n    } else if (this.state.mediaStream != null) {\n      return WebcamRequestState.SUCCESS\n    }\n    return WebcamRequestState.PENDING\n  }\n\n  /** Assign our mediaStream to a Video element. */\n  private assignMediaStream = (video: HTMLVideoElement): void => {\n    if (video != null && this.state.mediaStream != null) {\n      video.srcObject = this.state.mediaStream\n      video.play().catch(err => console.warn(`'video.play' error: ${err.toString()}`))\n    }\n  }\n\n  public render = (): ReactNode => {\n    const requestState = this.webcamRequestState\n    if (requestState === WebcamRequestState.SUCCESS) {\n      return (\n        <div>\n          <button onClick={this.captureFrame} disabled={this.props.disabled || this.state.imageCapture == null}>\n            Capture Frame\n          </button>\n          <video ref={this.assignMediaStream} height={500}/>\n        </div>\n      )\n    }\n\n    if (requestState === WebcamRequestState.FAILURE) {\n      return <div>Webcam error: {this.state.mediaStreamErr.toString()}</div>\n    }\n\n    return <div>Requesting webcam...</div>\n  }\n\n  private captureFrame = (): void => {\n    if (this.state.imageCapture == null) {\n      console.warn(\"Can't captureFrame: no imageCapture object!\")\n      return\n    }\n\n    this.state.imageCapture.grabFrame()\n      .then(renderBitmap)\n      .then(imageData => {\n        const data = {\n          width: imageData.width,\n          height: imageData.height,\n          data: Array.from(imageData.data),\n        }\n        Streamlit.setComponentValue(data)\n      })\n      .catch(err => {\n        console.error(`CaptureFrame error: ${err.toString()}`)\n      })\n  }\n}\n\n/** Render an ImageBitmap to a canvas to retrieve its ImageData. */\nfunction renderBitmap(bitmap: ImageBitmap): ImageData {\n  // Create a temporary canvas element to render into. We remove it at the end\n  // of the function.\n  const canvas = document.body.appendChild(document.createElement(\"canvas\"))\n  try {\n    canvas.width = bitmap.width\n    canvas.height = bitmap.height\n\n    let context = canvas.getContext(\"2d\")\n    if (context == null) {\n      throw new Error(\"Couldn't get 2D context from <canvas>\")\n    }\n\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    context.drawImage(bitmap, 0, 0)\n    return context.getImageData(0, 0, canvas.width, canvas.height)\n  } finally {\n    document.body.removeChild(canvas)\n  }\n}\n\n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(Webcam)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Webcam from \"./Webcam\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <Webcam />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}