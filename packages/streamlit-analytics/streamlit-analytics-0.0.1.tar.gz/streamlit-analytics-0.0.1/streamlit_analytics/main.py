from typing import Union
from contextlib import contextmanager
from pathlib import Path
import json

import streamlit as st


# Dict that holds all analytics results. Note that this is persistent across users,
# as modules are only imported once by a streamlit app.
counts = {}

# Store original streamlit functions. They will be monkey-patched with some wrappers
# in `start_tracking` (see wrapper functions below).
_orig_button = st.button
_orig_selectbox = st.selectbox
_orig_text_input = st.text_input


def _button_wrapper(label, *args, **kwargs):
    clicked = _orig_button(label, *args, **kwargs)
    if label not in counts:
        counts[label] = 0
    if clicked:
        counts[label] += 1
    # if verbose:
    #     print(f"Tracked button '{label}' -> clicked: {clicked}")
    return clicked


def _selectbox_wrapper(label, options, *args, **kwargs):
    selected = _orig_selectbox(label, options, *args, **kwargs)
    if label not in counts:
        counts[label] = {}
    for option in options:
        if option not in counts[label]:
            counts[label][option] = 0
    counts[label][selected] += 1
    # if verbose:
    #     print(f"Tracked selectbox '{label}' -> selected: {selected}")
    return selected


def _text_input_wrapper(label, *args, **kwargs):
    text = _orig_text_input(label, *args, **kwargs)
    if label not in counts:
        counts[label] = {}
    if text not in counts[label]:
        counts[label][text] = 0
    counts[label][text] += 1


def start_tracking(verbose: bool = False):
    """
    Start tracking user inputs to a streamlit app.
    
    If you call this function directly, you NEED to call 
    `streamlit_analytics.stop_tracking()` at the end of your streamlit script.
    For a more convenient interface, wrap your streamlit calls in 
    `with streamlit_analytics.track():`. 
    """

    # Monkey-patch streamlit to call the wrappers above.
    st.button = _button_wrapper
    st.selectbox = _selectbox_wrapper
    st.text_input = _text_input_wrapper

    if verbose:
        print()
        print("Tracking script execution with streamlit-analytics")


def stop_tracking(
    unsafe_password: str = None,
    save_to_json: Union[str, Path] = None,
    verbose: bool = False,
):
    """
    Stop tracking user inputs to a streamlit app.
    
    Should be called after `streamlit-analytics.start_tracking()`. This method also
    shows the analytics results below your app if you attach `?analytics=on` to the URL.
    """
    if verbose:
        print("Finished script execution. New counts:")
        print(counts)
        print("-" * 80)

    # Reset streamlit functions.
    st.button = _orig_button
    st.selectbox = _orig_selectbox
    st.text_input = _orig_text_input

    # Dump the counts to json file if `save_to_json` is set.
    # TODO: Make sure this is not locked if writing from multiple threads.
    if save_to_json is not None:
        with Path(save_to_json).open("w") as f:
            json.dump(counts, f)
        if verbose:
            print("Storing results to file:", save_to_json)

    # Show analytics results in the streamlit app if `?analytics=on` is set in the URL.
    query_params = st.experimental_get_query_params()
    if "analytics" in query_params and "on" in query_params["analytics"]:
        st.write("---")
        st.title("Analytics")
        st.markdown(
            """
            Psst! ðŸ‘€ You found a secret section generated by 
            [streamlit-analytics](https://github.com/jrieke/streamlit-analytics). 
            If you didn't mean to go here, remove `?analytics=on` from the URL.
            """
        )
        show_results = True
        if unsafe_password is not None:
            password_input = st.text_input("Enter password to show results")
            if password_input != unsafe_password:
                show_results = False
        if show_results:
            st.markdown(
                """
                <sub>Note: The numbers below add +1 each time streamlit executes your script 
                (= each time the user input changes). E.g. for st.selectbox, it adds +1 for 
                the current selection each time a user interacts with ANY component in your 
                app.</sub>
                
                """,
                unsafe_allow_html=True,
            )
            st.write(counts)


@contextmanager
def track(
    unsafe_password: str = None, save_to_json: Union[str, Path] = None, verbose=False
):
    """
    Context manager to start and stop tracking user inputs to a streamlit app.
    
    To use this, wrap all calls to streamlit in `with streamlit_analytics.track():`. 
    This also shows the analytics results below your app if you attach 
    `?analytics=on` to the URL.
    """
    start_tracking(verbose=verbose)
    # Yield here to execute the code in the with statement. This will call the wrappers
    # above, which track all inputs.
    yield
    stop_tracking(
        unsafe_password=unsafe_password, save_to_json=save_to_json, verbose=verbose
    )
