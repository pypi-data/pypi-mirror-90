Idp:
    Shebang?
    ( vocabularies=Vocabulary
    | theories=Theory
    | structures=Structure
    | procedures=Procedure) *
    goal=Goal?
    view=View?
    display=Display?
;

Comment:
  /\/\/.*$/
;

Shebang: '#!' /.*$/;

Vocabulary: 'vocabulary' (name=ID)? '{' (declarations=Declaration)* '}';
  Declaration: Extern | ConstructedTypeDeclaration | RangeDeclaration | SymbolDeclaration;

    Extern: 'extern' 'vocabulary' (name=ID);
    ConstructedTypeDeclaration: 'type' name=ID 'constructed' 'from' '{' constructors*=Constructor[','] '}';
      Constructor: name=/[^\d\W]\w*\b|'(\.|[^'])*'/;
    RangeDeclaration: 'type' name=ID '=' '{' elements*=RangeElement[';'] '}';
      RangeElement: fromI=NumberConstant ('..' toI=NumberConstant)?;

    SymbolDeclaration: annotations=Annotations name=Symbol ('(' sorts*=Sort[','] ')')? (':' out=Sort)?;
      Symbol: name=/`?[^\d\W]\w*\b|'(\.|[^'])*'/;
      Sort: name=/`?[^\d\W]\w*\b/;

  Annotations: ('[' annotations*=/[^\]]*/ ']')*;

Theory: 'theory' (name=ID ':' vocab_name=ID)? '{' ( definitions=Definition* (constraints=Expression '.')* interpretations=SymbolInterpretation* )* '}';

  Definition: '{' rules*=Rule '}';
  Rule: annotations=Annotations
        ('!' quantees=Quantee+ ':' )* symbol=Symbol args=Arguments? ('=' out=SumMinus)? ('<-' body=Expression)? '.' ;
      Quantee: var=/`?[^\d\W]\w*\b/ ('[' sort=Sort ']')? ;

  Expression: IfExpr | Quantification;
    IfExpr: 'if' if_f=Quantification 'then' then_f=Expression 'else' else_f=Expression;

    Quantification: AQuantification | RImplication;
    RImplication:   ARImplication   | Equivalence;
    Equivalence:    AEquivalence    | Implication;
    Implication:    AImplication    | Disjunction;
    Disjunction:    ADisjunction    | Conjunction;
    Conjunction:    AConjunction    | Comparison;
    Comparison:     AComparison     | SumMinus;
    SumMinus:       ASumMinus       | MultDiv;
    MultDiv:        AMultDiv        | Power;
    Power:          APower          | Unary;
    Unary:          AUnary          | Aggregate;
    Aggregate:      AAggregate      | Base;


    AQuantification: q=Quantor quantees=Quantee+ ':' f=Expression;
      Quantor: '∀' | '!' | '∃' | '?' ;
    ARImplication: sub_exprs=Equivalence (operator=RImplicationOp sub_exprs=Equivalence)+;
    AEquivalence:  sub_exprs=Implication (operator=EquivalenceOp  sub_exprs=Implication)+;
    AImplication:  sub_exprs=Disjunction (operator=ImplicationOp  sub_exprs=Disjunction)+;
    ADisjunction:  sub_exprs=Conjunction (operator=DisjunctionOp  sub_exprs=Conjunction)+;
    AConjunction:  sub_exprs=Comparison  (operator=ConjunctionOp  sub_exprs=Comparison )+;
    AComparison:   sub_exprs=SumMinus    (operator=ComparisonOp   sub_exprs=SumMinus   )+;
    ASumMinus:     sub_exprs=MultDiv     (operator=SumMinusOp     sub_exprs=MultDiv    )+;
    AMultDiv:      sub_exprs=Power       (operator=MultDivOp      sub_exprs=Power      )+;
    APower:        sub_exprs=Unary       (operator='^'            sub_exprs=Unary      );
    AUnary: !INT !IDPFLOAT               (operator=UnaryOperator  f=Aggregate);
    AAggregate: aggtype=AggType '{' quantees=Quantee*  ':' f=Expression (':'  out=Expression)? '}';
      AggType: '#' | 'card' | 'sum';

    RImplicationOp: '<=' | '⇐';
    EquivalenceOp: '<=>' | '⇔';
    ImplicationOp:  '=>' | '⇒';
    DisjunctionOp:   '|' | '∨';
    ConjunctionOp:   '&' | '∧';
    ComparisonOp:   '=<' | '>=' | '~=' | '=' | '<' | '>' | '≤' | '≥' | '≠' ;
    SumMinusOp:      '+' | '-';
    MultDivOp:       '*' | '/' | '%';
    UnaryOperator:   '-' | '~' | '¬';


    Base:  AppliedSymbol | Variable | NumberConstant | Brackets;

      AppliedSymbol: s=Symbol args=Arguments
              ( is_enumerated=/is\s+(not\s+)?enumerated/
              | 'in' in_enumeration=Enumeration)?;
        Arguments: '(' sub_exprs*=Expression[','] ')';
      Variable: s=Symbol;
      NumberConstant: number=IDPFLOAT | number=INT;
        IDPFLOAT: /[+-]?(\d+(\.\d+)?e[+-]?\d+|\.\d+e[+-]?\d+|\d+(\.\d+)?|\.\d+)/;
      Brackets: annotations=Annotations '(' f=Expression ')';


Structure: 'structure' (name=ID)? (':' vocab_name=ID)? '{' interpretations*=SymbolInterpretation '}';
  SymbolInterpretation: name=Symbol '=' ( default=Base '.' | enumeration=Enumeration ('else' default=Base)? );
  Enumeration : '{' tuples+=Tuple[';'] '}';
  Tuple : args*=Base[','];

Goal: 'goal' name=ID;

View: 'view' viewType=ViewType;
  ViewType: 'normal' | 'expanded';

Display: 'display' '{' (constraints=Expression '.')* '}';

Procedure: 'procedure' name=ID '(' args=ID*')' '{' pystatements=PyStatement* '}';

  PyStatement: Call1 | PyAssignment ;
  Call1 : name=ID '(' args*=Call0[','] (',' kwargs+=PyAssignment[','])? ')' ('.' post=PyExpr)?;
  Call0 : !PyAssignment pyExpr=PyExpr;
  PyExpr : Call1 | String | NumberConstant | ID | PyList;
  String: literal=/"(\.|[^"])*"/;
  PyList: '[' elements*=PyExpr[','] ']';

  PyAssignment : var=ID '=' val=Call0;

