(self.webpackChunk_kiteco_jupyterlab_kite=self.webpackChunk_kiteco_jupyterlab_kite||[]).push([[16],{1672:(e,t,n)=>{"use strict";n.r(t),n.d(t,{LSPConnection:()=>a});var i=n(1023),s=n(2984),o=n(6988),c=n(8104);class a extends s.LspWsConnection{constructor(e){super(e),this.closing_manually=!1,this.documentsToOpen=[],this.status_model=e.kite_status_model}sendOpenWhenReady(e){this.isReady?this._sendOpen(e):this.documentsToOpen.push(e)}onServerInitialized(e){for(super.onServerInitialized(e);this.documentsToOpen.length;){const e=this.documentsToOpen.pop();e&&this._sendOpen(e)}}async track(e,t,n){try{await this.connection.sendRequest("kite/track",{to:e,event:t,props:n})}catch(i){console.warn(`Could not track ${t}, ${n} to ${e}`)}}async fetchKiteOnboarding(){let e;try{return e=await this.connection.sendRequest("kite/onboarding"),i.basename(e)}catch(e){console.warn("Could not get Kite Onboarding file.")}return""}async fetchKiteStatus(e){let t=c.i;try{t=await this.connection.sendRequest("kite/status",{uri:e.uri})}catch(e){console.warn("Could not fetch Kite Status:",e)}return t}sendSelection(e,t,n){var i;try{this.connection.sendNotification("kite/selection",{positions:[{line:e.line,character:e.ch}],textDocument:{uri:t.uri},text:n})}catch(e){console.warn("[Kite] Selection Notification Error:",e)}null===(i=this.status_model)||void 0===i||i.refresh(this,t).catch((e=>console.log(e)))}sendSelectiveChange(e,t){this._sendChange([e],t)}sendFullTextChange(e,t){this._sendChange([{text:e}],t)}isRenameSupported(){return!(!this.serverCapabilities||!this.serverCapabilities.renameProvider)}async rename(e,t,n,i=!0){if(!this.isReady||!this.isRenameSupported())return;const s={textDocument:{uri:t.uri},position:{line:e.line,character:e.ch},newName:n},o=await this.connection.sendRequest("textDocument/rename",s);return i&&this.emit("renamed",o),o}initializeParams(){const e=super.initializeParams();return e.initializationOptions={kiteTypesEnabled:!0},e}connect(e){return super.connect(e),(0,o.EU)((()=>this.isConnected),-1).then((()=>{this.connection.onClose((()=>{this.isConnected=!1,this.emit("close",this.closing_manually)}))})).catch((()=>{console.error("Could not connect onClose signal")})),this}close(){try{this.closing_manually=!0,super.close()}catch(e){this.closing_manually=!1}}_sendOpen(e){var t;this.sendOpen(e),null===(t=this.status_model)||void 0===t||t.refresh(this,e).catch((e=>console.log(e)))}_sendChange(e,t){var n;if(!this.isConnected||!this.isInitialized)return;const i={textDocument:{uri:t.uri,version:t.version},contentChanges:e};this.connection.sendNotification("textDocument/didChange",i),t.version++,null===(n=this.status_model)||void 0===n||n.refresh(this,t).catch((e=>console.log(e)))}}}}]);