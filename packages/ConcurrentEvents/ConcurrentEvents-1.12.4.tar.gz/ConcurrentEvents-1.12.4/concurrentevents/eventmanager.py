import collections
import concurrent.futures
import logging
import time
from datetime import timedelta

from concurrentevents._exceptions import Cancel, StartError, EventError, HandlerError
from concurrentevents.tools import threadmonitor

logger = logging.getLogger('concurrentevents')


class EventManager:
    def __init__(self, threads=0):
        """
        A bare bones event framework using concurrent futures for threading
        :param int threads: The number of threads, default to none for automatic calculation
        """
        if threads < -1 if isinstance(threads, int) else True:
            raise ValueError(f"EventManager threads argument must be a int greater than 0 not {threads}")

        # Main dictionary for all event functionality
        # Stores handlers mapped to events to allow for quick access to specific ordered functions
        # Outline:
        #   key: Event
        #   value: List of handler functions
        self.handlers = collections.defaultdict(list)

        # Futures Dictionary
        # This is a private dictionary used internally so that the main thread can manage and clean
        #   the running futures generated by the event system
        # Outline:
        #   key: Future Object
        #   value: (fn, args, kwargs)
        self.__futures = {}

        self.__thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=threads or None)

        # This boolean is set so that after firing the start event on the main thread there
        #   are no other instances of it that could be created and thus no duplicate cleaners
        self.started = False
        self.exit = None

        # Integers to count various function for provide some runtime statics
        self.fired, self.finished, self.errors, self.canceled = 0, 0, 0, 0

    def add_handlers(self, *handlers):
        """
        Submits handlers into `EventManager` for organization and use
        :param handlers: A list of objects or functions that will be added to the handler dictionary
        """
        for h in handlers:
            try:
                for var in dir(h):
                    fn = getattr(h, var)
                    if callable(fn) and hasattr(fn, 'event'):
                        logger.debug(f"{var} is handling {fn.event}")
                        self.handlers[fn.event].append(fn)

                h.fire = lambda event, *args, **kwargs: self.fire(event, *args, **kwargs)
            except Exception as e:
                raise HandlerError(f"{fn} is not a valid handler {e}")

    def __handle(self, event, *args, **kwargs):
        if concurrent.futures.thread._shutdown is True:
            return

        if event in self.handlers.keys():
            handlers = sorted(self.handlers[event], key=lambda h: h.priority)
            logger.info(f"{[h.__name__ for h in handlers]} handling {event}(args={args}, kwargs={kwargs})")

            try:
                for h in handlers:
                    h(*args, **kwargs)
            except Cancel:
                self.canceled += 1

    def _submit(self, f, *args, **kwargs):
        """
        Interacts with the threadpool and futures dictionary to organize and track events

        This is implemented as the only methodology to put a function into the threadpool because,
        it forces all futures generated by putting something in the threadpool to be added to the
        futures list

        :param `function` f: A function object
        :param `*args`: Arguments for f
        :param `**kwargs`: Keyword arguments for f
        """
        future = self.__thread_pool.submit(f, *args, **kwargs)
        self.__futures[future] = (f, args, kwargs)
        return future

    def fire(self, event, *args, **kwargs):
        """
        A filter method for events that checks to see if it needs to be sent to the Thread Pool

        The purpose of this function is to validate not modify anything that
        wanted to be fired as an event.
        This intermediary step helps to eliminate anything that gets fired but
        isn't an event and any events that don't have handlers

        :param str event: A string representing a set of handlers for an event

        :raises EventError: Raised for when a non event is passed into the event param
        :raises KeyError: Raised for when there no handlers for the event
        """
        if event == 'Start':
            raise EventError('Can not fire Start as it is automatically fired from EventManager')

        if event == 'Exit':
            if not self.exit:
                if isinstance(kwargs['timeout'], int) if 'timeout' in kwargs else False:
                    self.exit = int(kwargs['timeout'])
                    kwargs.pop('timeout')
                else:
                    self.exit = 300

        if event not in self.handlers.keys():
            raise KeyError(f"No Handlers For {event}")

        self._submit(self.__handle, event, *args, **kwargs)
        self.fired += 1

    def start(self):
        """
        Starts the event sequence

        Fires the start event to trigger the beginning of all functionality
        After firing the start event the main while loop is started for debug
        and cleaning of completed futures
        """
        if 'Start' not in self.handlers.keys():
            raise StartError("EventManager can't start without handlers for the Start event")

        s = time.time()

        if self.started:
            raise StartError("EventManager is already running")
        self.started = True

        self._submit(self.__handle, 'Start')

        while not (self.exit or len(self.__futures) == 0):
            debug_info = [len(self.__futures) if len(self.__futures) != 1 else list(self.__futures.values())[0],
                          len([ft for ft in list(self.__futures.keys()) if ft.running()]),
                          dict(threadmonitor.thread_monitoring)]
            logger.debug("Status (futures={}, running={}, monitored={})".format(*debug_info))

            for f, fn in self.__futures.copy().items():
                if f.done():
                    self.__futures.pop(f)
                    try:
                        logger.debug(f"{fn[1][0]} ({self.finished}/{self.fired})")
                        f.result()
                        self.finished += 1
                    except Exception:
                        logger.exception(fn)
                        self.errors += 1

            time.sleep(0.25)

        if self.exit is None:
            self._submit(self.__handle, 'Exit')
            self.exit = 300

        waited = concurrent.futures.wait(list(self.__futures.keys()), timeout=self.exit)

        logger.debug(f"Runtime {timedelta(seconds=time.time() - s)}")
        logger.debug(f"Events Fired ({self.fired})")
        logger.debug(f"Events Finished ({self.finished + len(waited.done)})")
        logger.debug(f"Events Errors ({self.errors})")
        logger.debug(f"Events Canceled ({self.canceled})")

        self.__thread_pool.shutdown()
