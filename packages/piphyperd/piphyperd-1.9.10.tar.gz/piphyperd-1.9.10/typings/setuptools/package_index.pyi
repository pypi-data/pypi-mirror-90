"""
This type stub file was generated by pyright.
"""

import sys
import re
import configparser
import setuptools
from pkg_resources import Environment

"""PyPI and direct package downloading"""
EGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.+!]+)$')
HREF = re.compile(r"""href\s*=\s*['"]?([^'"> ]+)""", re.I)
PYPI_MD5 = re.compile(r'<a href="([^"#]+)">([^<]+)</a>\n\s+\(<a (?:title="MD5 hash"\n\s+)' r'href="[^?]+\?:action=show_md5&amp;digest=([0-9a-f]{32})">md5</a>\)')
URL_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).match
EXTENSIONS = ".tar.gz .tar.bz2 .tar .zip .tgz".split()
_SOCKET_TIMEOUT = 15
_tmpl = "setuptools/{setuptools.__version__} Python-urllib/{py_major}"
user_agent = _tmpl.format(py_major='{}.{}'.format(*sys.version_info), setuptools=setuptools)
def parse_requirement_arg(spec):
    ...

def parse_bdist_wininst(name):
    """Return (base,pyversion) or (None,None) for possible .exe name"""
    ...

def egg_info_for_url(url):
    ...

def distros_for_url(url, metadata=...):
    """Yield egg or source distribution objects that might be found at a URL"""
    ...

def distros_for_location(location, basename, metadata=...):
    """Yield egg or source distribution objects based on basename"""
    ...

def distros_for_filename(filename, metadata=...):
    """Yield possible egg or source distribution objects based on a filename"""
    ...

def interpret_distro_name(location, basename, metadata, py_version=..., precedence=..., platform=...):
    """Generate alternative interpretations of a source distro name

    Note: if `location` is a filesystem filename, you should call
    ``pkg_resources.normalize_path()`` on it before passing it to this
    routine!
    """
    ...

def unique_everseen(iterable, key=...):
    "List unique elements, preserving order. Remember all elements ever seen."
    ...

def unique_values(func):
    """
    Wrap a function returning an iterable such that the resulting iterable
    only ever yields unique items.
    """
    ...

REL = re.compile(r"""<([^>]*\srel\s*=\s*['"]?([^'">]+)[^>]*)>""", re.I)
@unique_values
def find_external_links(url, page):
    """Find rel="homepage" and rel="download" links in `page`, yielding URLs"""
    ...

class ContentChecker:
    """
    A null content checker that defines the interface for checking content
    """
    def feed(self, block):
        """
        Feed a block of data to the hash.
        """
        ...
    
    def is_valid(self):
        """
        Check the hash. Return False if validation fails.
        """
        ...
    
    def report(self, reporter, template):
        """
        Call reporter with information about the checker (hash name)
        substituted into the template.
        """
        ...
    


class HashChecker(ContentChecker):
    pattern = ...
    def __init__(self, hash_name, expected) -> None:
        ...
    
    @classmethod
    def from_url(cls, url):
        "Construct a (possibly null) ContentChecker from a URL"
        ...
    
    def feed(self, block):
        ...
    
    def is_valid(self):
        ...
    
    def report(self, reporter, template):
        ...
    


class PackageIndex(Environment):
    """A distribution index that scans web pages for download URLs"""
    def __init__(self, index_url=..., hosts=..., ca_bundle=..., verify_ssl=..., *args, **kw) -> None:
        ...
    
    def process_url(self, url, retrieve=...):
        """Evaluate a URL as a possible download, and maybe retrieve it"""
        ...
    
    def process_filename(self, fn, nested=...):
        ...
    
    def url_ok(self, url, fatal=...):
        ...
    
    def scan_egg_links(self, search_path):
        ...
    
    def scan_egg_link(self, path, entry):
        ...
    
    def process_index(self, url, page):
        """Process the contents of a PyPI page"""
        ...
    
    def need_version_info(self, url):
        ...
    
    def scan_all(self, msg=..., *args):
        ...
    
    def find_packages(self, requirement):
        ...
    
    def obtain(self, requirement, installer=...):
        ...
    
    def check_hash(self, checker, filename, tfp):
        """
        checker is a ContentChecker
        """
        ...
    
    def add_find_links(self, urls):
        """Add `urls` to the list that will be prescanned for searches"""
        ...
    
    def prescan(self):
        """Scan urls scheduled for prescanning (e.g. --find-links)"""
        ...
    
    def not_found_in_index(self, requirement):
        ...
    
    def download(self, spec, tmpdir):
        """Locate and/or download `spec` to `tmpdir`, returning a local path

        `spec` may be a ``Requirement`` object, or a string containing a URL,
        an existing local filename, or a project/version requirement spec
        (i.e. the string form of a ``Requirement`` object).  If it is the URL
        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one
        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is
        automatically created alongside the downloaded file.

        If `spec` is a ``Requirement`` object or a string containing a
        project/version requirement spec, this method returns the location of
        a matching distribution (possibly after downloading it to `tmpdir`).
        If `spec` is a locally existing file or directory name, it is simply
        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath
        of `tmpdir`, and the local filename is returned.  Various errors may be
        raised if a problem occurs during downloading.
        """
        ...
    
    def fetch_distribution(self, requirement, tmpdir, force_scan=..., source=..., develop_ok=..., local_index=...):
        """Obtain a distribution suitable for fulfilling `requirement`

        `requirement` must be a ``pkg_resources.Requirement`` instance.
        If necessary, or if the `force_scan` flag is set, the requirement is
        searched for in the (online) package index as well as the locally
        installed packages.  If a distribution matching `requirement` is found,
        the returned distribution's ``location`` is the value you would have
        gotten from calling the ``download()`` method with the matching
        distribution's URL or filename.  If no matching distribution is found,
        ``None`` is returned.

        If the `source` flag is set, only source distributions and source
        checkout links will be considered.  Unless the `develop_ok` flag is
        set, development and system eggs (i.e., those using the ``.egg-info``
        format) will be ignored.
        """
        ...
    
    def fetch(self, requirement, tmpdir, force_scan=..., source=...):
        """Obtain a file suitable for fulfilling `requirement`

        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For
        backward compatibility, this routine is identical but returns the
        ``location`` of the downloaded distribution instead of a distribution
        object.
        """
        ...
    
    def gen_setup(self, filename, fragment, tmpdir):
        ...
    
    dl_blocksize = ...
    def reporthook(self, url, filename, blocknum, blksize, size):
        ...
    
    def open_url(self, url, warning=...):
        ...
    
    def scan_url(self, url):
        ...
    
    def debug(self, msg, *args):
        ...
    
    def info(self, msg, *args):
        ...
    
    def warn(self, msg, *args):
        ...
    


entity_sub = re.compile(r'&(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?').sub
def decode_entity(match):
    ...

def htmldecode(text):
    """
    Decode HTML entities in the given text.

    >>> htmldecode(
    ...     'https://../package_name-0.1.2.tar.gz'
    ...     '?tokena=A&amp;tokenb=B">package_name-0.1.2.tar.gz')
    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B">package_name-0.1.2.tar.gz'
    """
    ...

def socket_timeout(timeout=...):
    ...

class Credential:
    """
    A username/password pair. Use like a namedtuple.
    """
    def __init__(self, username, password) -> None:
        ...
    
    def __iter__(self):
        ...
    
    def __str__(self) -> str:
        ...
    


class PyPIConfig(configparser.RawConfigParser):
    def __init__(self) -> None:
        """
        Load from ~/.pypirc
        """
        ...
    
    @property
    def creds_by_repository(self):
        ...
    
    def find_credential(self, url):
        """
        If the URL indicated appears to be a repository defined in this
        config, return the credential for that repository.
        """
        ...
    


def open_with_auth(url, opener=...):
    """Open a urllib2 request, handling HTTP authentication"""
    ...

open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)
def fix_sf_url(url):
    ...

def local_open(url):
    """Read a local path, with special support for directories"""
    ...

