"""Task handling for all transports."""
import os
import re
import shutil
import json
from collections import OrderedDict
from slugify import slugify
from jinja2 import Template
from yangsuite.paths import register_path, get_path
from yangsuite.logs import get_logger
from ysdevices import YSDeviceProfile
from distutils import dir_util

log = get_logger(__name__)


class TaskException(Exception):
    """Base exception class for Tasks."""

    def __init__(self, msg=''):
        """Set default message if non given."""
        if not msg:
            msg = 'No task reply'
        super(TaskException, self).__init__(msg)


class TaskNotFoundException(TaskException):
    """Task name not found at path."""

    def __init__(self, name):
        """Return connect fail."""
        msg = 'Task "{0}" does not exist'.format(name)
        super(TaskNotFoundException, self).__init__(msg)


class TaskHandler(object):
    """Handle task actions like save, get, delete.

    .. automethod:: __init__
    """

    @classmethod
    def get_category_list(cls, path, generated_only=False):
        """Retrieve the list of available categories.

        Args:
          path (str): Directory containing category directories
          generated_only (bool): If True, only list categories that contain
            at least one autogenerated replay.

        Returns:
          list: of category names
        """
        categories = []

        for path, _, files in os.walk(path):
            for f in files:
                if f.endswith('.tsk'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            replay = json.load(fd)
                            if not generated_only:
                                categories.append(replay['category'])
                                break
                            elif (replay.get('autogenerated', False) or
                                  ('autogenerated' not in replay and
                                   re.match('^\d\d\d\d\d -', replay['name']))):
                                categories.append(replay['category'])
                                break
                        except json.JSONDecodeError as e:
                            log.error("Replay {0} JSON error:\n{1}"
                                      .format(f, str(e)))

        return sorted(categories)

    @classmethod
    def get_task_list(cls, path):
        """Retrieve the list of categories with tasks.

        Args:
          path (str): Directory containing categories and replays.

        Returns:
          dict: ``{category: [[name, filename (, variables)], ...], ...}``
        """
        tasks = {}

        # If we're requesting replay files from a standard location,
        # fix up any replays from the legacy equivalent location first.
        if (os.path.basename(path) == 'replays' and
                os.path.basename(os.path.dirname(path)) == 'testing'):
            migrate_replay_files(path)

        for path, sub, files in os.walk(path):
            for f in files:
                if f.endswith('.tsk'):
                    with open(os.path.join(path, f)) as fd:
                        try:
                            replay = json.load(fd)
                            if 'category' not in replay:
                                log.error(
                                    "Replay {0} missing category"
                                    .format(f)
                                )
                                continue
                            if replay['category'] in tasks:
                                tasks[replay['category']].append(
                                    [replay['name'], f]
                                )
                            else:
                                tasks[replay['category']] = [
                                    [replay['name'], f]
                                ]
                        except json.JSONDecodeError as e:
                            log.error(
                                "Replay {0} JSON error:\n{1}"
                                .format(f, str(e))
                            )
                            continue

        sorted_tasks = OrderedDict()

        for category in sorted(tasks.keys()):
            sorted_tasks[category] = sorted(tasks[category])
        return sorted_tasks

    @classmethod
    def delete_category(cls, user, category):
        """Delete the given category and all replays it contains.

        Args:
          category (str): Name of category to delete.

        Returns:
          dict: {"result": success message}

        Raises:
          TaskException: if the requested category doesn't exist.
        """
        path = get_path('replay_category_dir', user=user, category=category)
        if not os.path.isdir(path):
            raise TaskException("No such category")
        shutil.rmtree(path)
        return {"result": 'Successfully deleted "{0}"'.format(category)}

    @classmethod
    def replay_file_path(cls, path, category, replay):
        """Path to a replay file in a category under the given base path."""
        if not category:
            raise ValueError("Category must be specified")
        return os.path.join(path, slugify(category), slugify(replay) + '.tsk')

    @classmethod
    def get_replay(cls, path, category, replay, variables=None):
        """Retrieve the data dictionary describing the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Replay category name
          replay (str): Replay name
          variables (dict): Mapping variable names to values; if specified,
            these will be substituted into the replay dict before returning it.

        Returns:
          dict: describing the replay in question.

        Raises:
          TaskNotFoundException: if the requested replay does not exist.
        """
        # If we're requesting a replay file from a standard location,
        # fix up any replays from the legacy equivalent location first.
        if (os.path.basename(path) == 'replays' and
                os.path.basename(os.path.dirname(path)) == 'testing'):
            migrate_replay_files(path)

        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            if variables:
                vars_list = cls.get_xml_str_replay_variables(path, category,
                                                             replay)

                for list_item in vars_list['str_var']:
                    if list_item not in variables:
                        variables[list_item] = "{{" + list_item + "}}"

                for list_item in vars_list['xml_var']:
                    if list_item not in variables:
                        variables[list_item] = "_-" + list_item + "-_"

                tpl = Template(fd.read(),
                               variable_start_string="{{",
                               variable_end_string="}}")
                data = tpl.render(variables)
                tpl2 = Template(data,
                                variable_start_string="_-",
                                variable_end_string="-_")
                data = tpl2.render(variables)
                replay = json.loads(data)
            else:
                replay = json.load(fd)

        # Clean up obsolete data if present
        if 'filename' in replay:
            del replay['filename']

        # Add newer data if absent
        if 'autogenerated' not in replay:
            if re.match("^\d\d\d\d\d -", replay['name']):
                replay['autogenerated'] = True
            else:
                replay['autogenerated'] = False

        return replay

    VARIABLE_RE = re.compile(r'(?:{{|_-)\s*(\S+?)\s*(?:}}|-_)')
    VARIABLE_RE_STR = re.compile(r'(?:{{)\s*(\S+?)\s*(?:}})')
    VARIABLE_RE_XML = re.compile(r'(?:_-)\s*(\S+?)\s*(?:-_)')
    """Pattern matching a variable declaration in a replay."""

    @classmethod
    def get_replay_variables(cls, path, category, replay):
        """Get the list of variables applicable to the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Category name
          replay (str) Replay name

        Returns:
          list: of variable names
        """
        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            replay_text = fd.read()
        vars = cls.VARIABLE_RE.findall(replay_text)
        variables = set()
        for v in vars:
            variables.add(v.strip())
        return sorted(variables)

    @classmethod
    def get_xml_str_replay_variables(cls, path, category, replay):
        """Get the list of string and xml variables
           applicable to the given replay.

        Args:
          path (str): Base tasks/replays directory
          category (str): Category name
          replay (str) Replay name

        Returns:
          dict: of variable names
        """
        file_path = cls.replay_file_path(path, category, replay)
        if not os.path.exists(file_path):
            raise TaskNotFoundException(replay)
        with open(file_path) as fd:
            replay_text = fd.read()
        vars_xml = cls.VARIABLE_RE_XML.findall(replay_text)
        vars_str = cls.VARIABLE_RE_STR.findall(replay_text)
        var_dict = {}
        variables_xml = set()
        variables_str = set()

        for x in vars_xml:
            variables_xml.add(x.strip())
        var_dict["xml_var"] = sorted(variables_xml)

        for s in vars_str:
            variables_str.add(s.strip())
        var_dict["str_var"] = sorted(variables_str)

        return var_dict

    def __init__(self, name, path, cfg={}):
        """Initialize TaskHandler.

        Args:
          name (str): Task name.
          path (str): Path to local task directory.
          cfg (dict): Task configuration contains:

            - category (str): User defined category
              TODO: category should be split out into a top-level parameter,
              instead of a part of this dictionary, as the dictionary is
              otherwise optional for some APIs.
            - description (str): Description of task
            - autogenerated (bool): Is this an auto-generated replay?
            - devices (list): Devices this task was tested on
            - platforms (list): Platforms this task was tested on
            - images (list): Images this task was tested on
            - variables (dict): Variables and their assigned values
              (only used in retrieve_task() at present)
            - segments (list or str): List of dicts of info needed
              to form RPC(s), each with structure::

                {
                  'segment': '1',
                  'commit': '',
                  'cfgd': {
                    'proto-op': 'edit-config',
                    'modules': {
                      'revision': '2018-01-05',
                      'namespace_prefixes': { ... },
                      'configs': [ ... ],
                    }
                  }
                }

            **OR** a single string containing RPC XML.
        """
        self.name = name
        self.category = cfg['category']
        self.path = path
        self.description = cfg.get('description', 'No description')
        self.autogenerated = cfg.get('autogenerated', False)
        self.segments = cfg.get('segments', [])
        self.platforms = cfg.get('platforms', [])
        self.devices = cfg.get('devices', '')
        self.images = cfg.get('images', [])
        self.variables = cfg.get('variables', {})

    @property
    def name(self):
        """Human-readable name of this replay."""
        return self._name

    @name.setter
    def name(self, name):
        self._name = name
        self._slug_name = slugify(name)

    @property
    def category(self):
        """Human-readable name of the category containing this replay."""
        return self._category

    @category.setter
    def category(self, cat):
        """NOTE: only call this at initialization time, as self.path
        will NOT be updated if the category is changed."""
        self._category = cat
        self._slug_category = slugify(cat)

    @property
    def path(self):
        """Path to category directory containing this replay file."""
        return self._path

    @path.setter
    def path(self, path):
        """NOTE: the provided `path` is the parent directory of `self.path`."""
        if path and os.path.isfile(path):
            raise TaskNotFoundException('\nPath is a file\n' + path)
        if not path or not os.path.isdir(path):
            raise TaskNotFoundException(path)

        self._path = os.path.join(path, self._slug_category)
        # need this if category changes
        self._base_path = path

    @property
    def file_path(self):
        """Path where replay file is/will be saved."""
        return os.path.join(self.path, self._slug_name + '.tsk')

    @property
    def platforms(self):
        """List of platforms tested on.

        TODO: This is currently a list of
        YSDeviceProfile.netconf.device_variant strings, but it needs to
        be updated to be 1) protocol-agnostic and 2) more granular.
        """
        return list(self._platforms)

    @platforms.setter
    def platforms(self, platforms):
        self._platforms = set(platforms)

    @property
    def devices(self):
        """List of device profile names tested on."""
        return list(self._devices)

    @devices.setter
    def devices(self, devs=[]):
        self._devices = devs
        platforms = set()
        for dev in devs:
            try:
                profile = YSDeviceProfile.get(dev)
                if hasattr(profile, 'netconf'):
                    platforms.add(profile.netconf.device_variant)
            except:
                continue
        # platform types will be saved to make the task portable
        if hasattr(self, "_platforms"):
            self._platforms.update(platforms)
        else:
            self._platforms = platforms

    @property
    def variables(self):
        """Dict of variables to values to insert when calling retrieve_task."""
        return self._variables

    @variables.setter
    def variables(self, var):
        if isinstance(var, (str, bytes)):
            self._variables = json.loads(var)
        elif isinstance(var, dict):
            self._variables = var
        else:
            self._variables = {}

    def retrieve_task(self):
        """Load the described replay from disk and return it as a dict.

        This will substitute in any variable values defined in self.variables.

        Returns:
          dict: ``{'task': (dict)}``

        Raises:
          TaskNotFoundException: if the task file does not exist
        """
        return {
            'task': self.get_replay(self._base_path,
                                    self.category,
                                    self.name,
                                    self.variables),
        }

    def save_task(self, overwrite=False):
        """Save the data that this instance contains to a file on disk.

        Raises:
          TaskException: if ``self.segments`` is unset
          TaskException: if the target file already exists
        """
        if not self.segments:
            raise TaskException('No RPCs for {0} task.'.format(
                self.name))

        try:
            if not os.path.exists(self.path):
                os.makedirs(self.path)
            elif not os.path.isdir(self._path):
                raise TaskException('File exists with same name as category')
            if os.path.isfile(self.file_path) and not overwrite:
                log.warning('{0} already exists.'.format(self.name))
                raise TaskException('{0} already exists.'.format(self.name))

            task = {'name': self.name,
                    'description': self.description,
                    'category': self.category,
                    'autogenerated': self.autogenerated,
                    'platforms': self.platforms,
                    'images': self.images,
                    'segments': []}

            rpcs = self.segments

            if isinstance(rpcs, list) or isinstance(rpcs, tuple):
                for rpc in rpcs:
                    if 'cfgd' not in rpc:
                        # Assuming this segment is constructed correctly
                        # as shown in segment dicts below.
                        task['segments'].append(rpc)
                    elif 'cfgd' in rpc:
                        # Need to build this segment based on format of GUI
                        # TODO: GUI should be converted to same format used
                        #       in backend which adjusted for multiple models
                        cfgd = rpc['cfgd']

                        segment = {
                            'segment': rpc['segment'],
                            'description': self.description,
                            'commit': rpc['commit'],
                            'cli': rpc.get('cli', ''),
                            'cli_verify': rpc.get('cli_verify', ''),
                            'yang': {
                                'proto-op': cfgd['proto-op'],
                                'modules': cfgd['modules']
                            }
                        }

                        task['segments'].append(segment)
            elif hasattr(rpcs, 'splitlines'):
                #  custom RPC string saved to task
                rpc = ''
                ctr = 1
                for line in rpcs.splitlines():
                    rpc += line + '\n'
                    if line.endswith('rpc>'):
                        segment = {
                            'segment': ctr,
                            'description': self.description,
                            'commit': '',
                            'yang': {
                                'proto-op': 'custom',
                                'rpc': rpc
                            }
                        }

                        task['segments'].append(segment)
                        ctr += 1
                        rpc = ''
            else:
                raise TaskException('Unexpected data type for "rpcs": {0}'
                                    .format(type(rpcs)))

            with open(self.file_path, 'w') as fd:
                json.dump(task, fd, indent=2, sort_keys=True)

            return '{0} saved.'.format(self.name)

        except Exception as e:
            log.error('Save task {0} at {1} failed'.format(
                self.name, self.path))
            raise e

    def edit_task(self, name, category):
        """Edit metadata of an existing replay.

        Can update the replay's:

          - name (as provided in the args)
          - category (as provided in the args)
          - description (using self.description)
          - platforms (using self.platforms)
          - images (using self.images)

        Use save_task_data to update segments, autogenerated, variables.

        Args:
          name (str): Task name (may be new)
          category (str): Task category (may be new)

        Raises:
          TaskNotFoundException: if no existing task file is found
        """
        try:
            file_path = ''
            oldfile = ''

            if os.path.isfile(self.file_path):
                file_path = self.file_path
            else:
                log.error('{0} does not exist'.format(self.name))
                raise TaskNotFoundException(self.name)

            with open(file_path) as fd:
                task = json.load(fd)

            task['name'] = name
            task['category'] = category
            task['description'] = self.description
            task['platforms'] = self.platforms
            task['images'] = self.images

            # new name or new category - file changes are needed
            if (name, category) != (self.name, self.category):
                newfile = self.replay_file_path(self._base_path,
                                                category, name)

                if os.path.isfile(newfile):
                    log.warning('{0} already exists.'.format(self.name))
                    raise TaskException('{0} already exists.'.format(
                        self.name))

                # when modify works we will get rid of this one
                oldfile = file_path

                file_path = newfile

                # new category?
                if not os.path.exists(os.path.join(self._base_path,
                                                   slugify(category))):
                    os.makedirs(os.path.join(self._base_path,
                                             slugify(category)))

            # write new task contents
            with open(file_path, 'w') as fd:
                json.dump(task, fd, indent=2, sort_keys=True)

            if os.path.isfile(oldfile):
                # name or category was changed so get rid of old file
                os.remove(oldfile)

            if not [f for f in os.listdir(self.path) if f.endswith('.tsk')]:
                shutil.rmtree(self.path)

            return_msg = '{0} modified.'.format(self.name)
            self.name = name
            self.category = category
            self.path = self._base_path

            return return_msg

        except Exception as e:
            log.error('Edit task {0} at {1} failed'.format(
                self.name, self.path))
            raise e

    def del_task(self):
        """Delete this replay's file from disk, and possibly the category too.

        Raises:
          TaskNotFoundException: if no such replay file exists
        """
        try:
            file_path = ''

            if os.path.isfile(self.file_path):
                file_path = self.file_path
            else:
                log.error('{0} does not exist'.format(self.name))
                raise TaskNotFoundException(self.name)

            os.remove(file_path)

            if not [f for f in os.listdir(self.path) if f.endswith('.tsk')]:
                shutil.rmtree(self.path)

            return 'Deleted replay "{0}"'.format(self.name)
        except Exception as e:
            log.error('Delete of replay "{0}" at {1} failed'.format(
                self.name, self.path))
            raise e

    def save_task_data(self, task):
        """Update an existing replay with new contents.

        Args:
          task (str): JSON string describing the data to be saved

        Raises:
          TaskNotFoundException: if ``self.name`` is unset (TODO?)
          TaskException: if ``task`` is not set
          TaskNotFoundException: if no previous replay file exists
        """
        if not self.name:
            raise TaskNotFoundException(self.name)
        if not task:
            raise TaskException("No RPCs to save")
        file_path = ''
        if os.path.isfile(self.file_path):
            file_path = self.file_path
        else:
            log.error('{0} does not exist'.format(self.name))
            raise TaskNotFoundException(self.name)

        with open(file_path, 'w') as fd:
            task = json.loads(task)
            json.dump(task, fd, indent=2, sort_keys=True)

        return '{0} data saved'.format(self.name)


def set_replay_path(replay_dir):
    """Set replay path to an alternative base.

    """
    register_path('replay_base_dir', replay_dir, replace=True)
    register_path('replays_dir', 'replays',
                  parent='replay_base_dir', autocreate=True, replace=True)
    # Deprecated, to be removed:
    register_path('tasks_dir', 'replays',
                  parent='replay_base_dir', autocreate=True, replace=True)

    log.info("Replay path set to %s", replay_dir)


def reset_replay_path(user):
    """Set replay path to default base."""
    register_path('replays_dir', 'replays',
                  parent='testing_dir', autocreate=True, replace=True)
    # Deprecated, to be removed:
    register_path('tasks_dir', 'replays',
                  parent='testing_dir', autocreate=True, replace=True)

    log.info("Replay path set to default")

    return get_path('replays_dir', user=user)


def check_replays_subdir(replay_dir_path):
    """Check if replays sub directory exist under top directory"""
    dir_name = os.path.basename(replay_dir_path)

    if dir_name.lower() == 'replays':
        return True
    else:
        return False


def check_default_replay_dir(replay_dir_path, request):
    """Check if it is default replay directory path"""
    dir_name = os.path.basename(replay_dir_path)

    if dir_name.lower() == 'tasks':
        # Check if directory ending with tasks is the default replay directory.
        default_dir_path = get_path('tasks_dir', user=request.user.username)
        if replay_dir_path == default_dir_path:
            return True
        else:
            return False
    else:
        return False


def migrate_replay_files(target_path):
    """Migrate replay files from ../../tasks to ../../testing/replays.

    Args:
      target_path: Directory path ending in "testing/replays"
    """
    if os.path.basename(target_path) != 'replays':
        return
    if os.path.basename(os.path.dirname(target_path)) != 'testing':
        return
    base_path = os.path.dirname(os.path.dirname(target_path))

    legacy_path = os.path.join(base_path, 'tasks')
    if not os.path.isdir(legacy_path):
        return

    dir_util.copy_tree(legacy_path, target_path)
    dir_util.remove_tree(legacy_path)
