"""Task handling Django APIs for all transports."""
import os
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from django.contrib.admin.views.decorators import staff_member_required
from yangsuite.paths import get_path
from yangsuite.logs import get_logger
from .. import TaskException, TaskHandler, set_replay_path, reset_replay_path
from .. import check_replays_subdir, check_default_replay_dir
from .utilities import json_request


log = get_logger(__name__)


@login_required
@json_request
def save_task(request, jsondata):
    """Save a collection of task objects.

    Args:
      request (django.http.HttpRequest): HTTP request
      jsondata (dict): Parsed from request.body, with expected keys:

        - name (str): Name of task
        - description (str): Description of task
        - category (str): User defined category
        - autogenerated (bool): Whether this is an auto-generated replay or
          a manually constructed one.
        - devices (list): Devices this task was tested on
        - images (list): Images this task was tested on
        - segments (dict): All information needed to form multiple RPCs
        - overwrite (bool): Whether to overwrite an existing replay if any.
    """
    name = jsondata.get('name')
    path = get_path('replays_dir', user=request.user.username)
    category = jsondata.get('category')
    if not category or not name:
        return JsonResponse({}, status=400,
                            reason='Missing mandatory parameter')

    try:
        result = TaskHandler(name, path, jsondata).save_task(
            jsondata.get('overwrite', False))
        return JsonResponse({'reply': '{0}'.format(result)}, status=200)
    except TaskException as e:
        return JsonResponse({}, status=500, reason=str(e))


@login_required
@json_request
def edit_task(request, jsondata):
    """Edit an existing task.

    Args:
      request (django.http.HttpRequest): HTTP request

        - name (str): Name of task
        - newName (str): New name of task
        - description (str): Description of task
        - devices (list): Devices this task was tested on
        - category (str): User defined category
        - newCat (str): New category
        - images (list): Images this task was tested on
    """
    name = jsondata.get('name')
    new_name = jsondata.get('newName')
    new_category = jsondata.get('newCat')
    path = get_path('replays_dir', user=request.user.username)

    try:
        th = TaskHandler(name, path, jsondata)
        result = th.edit_task(new_name, new_category)
        return JsonResponse({'reply': '{0}'.format(result)}, status=200)
    except TaskException as e:
        return JsonResponse({}, status=500, reason=str(e))


@login_required
def del_task(request):
    """Delete task.

    Args:
      name (str): Name of task to delete
      names[] (str): List of tasks to delete
      category (str): Category containing all task(s) to delete
    """
    path = get_path('replays_dir', user=request.user.username)

    name = request.POST.get('name')
    if name:
        names = [name]
    else:
        names = request.POST.getlist('names[]')

    if not request.POST.get('category'):
        return JsonResponse({}, status=400, reason='No category specified')

    tasks_deleted = 0
    last_exc = None
    for name in names:
        try:
            result = TaskHandler(name, path, request.POST.dict()).del_task()
            tasks_deleted += 1
        except TaskException as e:
            last_exc = e

    if len(names) == 1:
        if tasks_deleted == 1:
            return JsonResponse({'reply': result}, status=200)
        else:
            return JsonResponse({}, status=500, reason=str(last_exc))
    elif len(names) == tasks_deleted:
        return JsonResponse({'reply': "{0} replays deleted successfully"
                             .format(tasks_deleted)}, status=200)
    else:
        return JsonResponse({'reply': "{0} of {1} replays deleted successfully"
                             .format(tasks_deleted, len(names))},
                            status=200)


@login_required
def get_task(request):
    """Retrieve a task or list of tasks and return json.

    Args:
      name (str): Name of task. If omitted, get a listing of tasks instead.
    """
    name = request.POST.get('name')

    path = get_path('replays_dir', user=request.user.username)

    try:
        if not name:
            # caller wants the whole list
            result = TaskHandler.get_task_list(path)
        else:
            result = {
                'task': TaskHandler.get_replay(
                    path, request.POST.get('category'), name,
                    request.POST.get('variables', {}))
            }
        return JsonResponse(result, status=200)
    except TaskException as e:
        return JsonResponse({}, status=500, reason=str(e))


@login_required
def get_category_list(request):
    """Get the list of replay categories.

    Args:
      generated_only (str): If 'true', only list categories that contain
        at least one autogenerated replay.
    """
    generated_only = request.GET.get('generated_only', '')
    generated_only = (generated_only == 'true')
    path = get_path('replays_dir', user=request.user.username)

    return JsonResponse({
        'categories': TaskHandler.get_category_list(path, generated_only),
    })


@login_required
def get_task_list(request):
    """Get the list of tasks for a category.
    """

    category = request.POST.get('category', '')
    path = get_path('replays_dir', user=request.user.username)
    task_list = TaskHandler.get_task_list(path)
    if task_list:
        task_list = task_list[category]
    else:
        task_list = []
    return JsonResponse({
        'tasks': task_list
    })


@login_required
def get_replay_variables(request):
    """Get the list of variables used in a specific replay.

    Args:
      name (str): Name of replay.
      category (str): Category of replay

    Returns:
      JsonResponse
    """
    name = request.GET.get('name')
    category = request.GET.get('category')
    if not name or not category:
        return JsonResponse({}, status=400, reason="Missing mandatory arg")
    variables = TaskHandler.get_replay_variables(
        get_path('replays_dir', user=request.user.username),
        category, name)
    return JsonResponse({"variables": variables})


@login_required
def save_task_data(request):
    """Update an existing replay with new contents.

    Args:
      name (str): Name of task.
      category (str): Category of task
      task (JSON): Task to be saved
    """
    name = request.POST.get('name')
    category = request.POST.get('category')
    task = request.POST.get('task')
    if not name or not category or not task:
        return JsonResponse({}, status=400, reason="Missing mandatory arg")

    path = get_path('replays_dir', user=request.user.username)

    try:
        th = TaskHandler(name, path, {'category': category})
        result = th.save_task_data(task)
        return JsonResponse({'result': '{0}'.format(result)}, status=200)
    except TaskException as e:
        return JsonResponse({}, status=500, reason=str(e))


@login_required
def delete_category(request):
    """Delete a given category and its associated replays."""
    category = request.POST.get('category')
    try:
        result = TaskHandler.delete_category(request.user.username, category)
        return JsonResponse(result, status=200)
    except TaskException as e:
        return JsonResponse({}, status=500, reason=str(e))


@login_required
def change_category(request):
    """Move one or more replays into a different category."""
    replays = request.POST.getlist('replays[]')
    old_category = request.POST.get('old_category')
    new_category = request.POST.get('new_category')

    path = get_path('replays_dir', user=request.user.username)

    errors = []

    for replay in replays:
        try:
            # TODO, is there a less convoluted way to do this?
            th = TaskHandler(replay, path, {'category': old_category})
            data = th.retrieve_task()
            th2 = TaskHandler(replay, path, data['task'])
            th2.edit_task(replay, new_category)
        except TaskException as e:
            errors.append(str(e))

    if errors:
        return JsonResponse({
            'result': 'Not all replays were successfully moved',
            'errors': errors
        })
    else:
        return JsonResponse({
            'result': 'Replays successfully moved',
            'errors': errors
        })


@login_required
def get_top_replay_dir(request):
    """Get top directory containing replay categories."""
    return JsonResponse({'replaydir': get_path('replays_dir',
                                               user=request.user.username)})


@login_required
@staff_member_required
def set_top_replay_dir(request):
    """Set top directory containing replay categories."""

    if request.method == 'POST':
        # TODO: POST uses 'replay_dir', but the replies use 'replaydir'
        replay_dir_path = request.POST.get('replay_dir')
        createDirectory = request.POST.get('createDirectory')

        if not replay_dir_path:
            return JsonResponse({}, status=400,
                                reason="No directory location sent")

        if createDirectory.lower() == 'false':
            # Check if the top directory exists or not
            dir_exists = os.path.isdir(replay_dir_path)

            if not dir_exists:
                return JsonResponse({"replay_dir_path": replay_dir_path},
                                    status=404,
                                    reason="Directory does not exist")
            else:
                # Check if 'replays' sub directory exists or not
                if not check_replays_subdir(replay_dir_path):

                    if not check_default_replay_dir(replay_dir_path, request):
                        base_dir_path = replay_dir_path
                        replay_dir_path = os.path.join(replay_dir_path,
                                                       'replays')
                        # For handling, replays subdir present but not ending
                        # in replay_dir_path
                        if not os.path.isdir(replay_dir_path):
                            os.makedirs(replay_dir_path)
                    else:
                        return JsonResponse({"replay_dir_path":
                                            replay_dir_path},
                                            status=200,
                                            reason="Directory set")
                else:
                    base_dir_path = os.path.dirname(replay_dir_path)

                set_replay_path(base_dir_path)
                return JsonResponse({"replay_dir_path": replay_dir_path},
                                    status=200,
                                    reason="Directory set")
        elif createDirectory.lower() == 'true':
            if not check_replays_subdir(replay_dir_path):
                base_dir_path = replay_dir_path
                replay_dir_path = os.path.join(replay_dir_path, 'replays')
            else:
                base_dir_path = os.path.dirname(replay_dir_path)

            os.makedirs(replay_dir_path)
            set_replay_path(base_dir_path)
            return JsonResponse({"replay_dir_path": replay_dir_path},
                                status=200,
                                reason="Directory set")
        else:
            return JsonResponse({}, status=400,
                                reason="Unable to set replay directory path")


@login_required
@staff_member_required
def reset_top_replay_dir(request):
    """Set top replay directory back to default."""
    if request.method == 'POST':
        replay_dir = reset_replay_path(request.user.username)
        return JsonResponse({'replaydir': replay_dir}, status=200)
